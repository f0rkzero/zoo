-- Anti Cheat Bypasser
local mt = getrawmetatable(game)
setreadonly(mt, false)

local oldNamecall = mt.__namecall

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    
    if method == "Kick" or tostring(self) == "Kick" then
        warn("[AntiKick] Kick attempt blocked.")
        return nil
    end

    return oldNamecall(self, unpack(args))
end)


-- Library Initializer

getgenv().namehub = "Steal a BrainRot"
local UserInputService = game:GetService('UserInputService')
local LocalPlayer = game:GetService('Players').LocalPlayer
local TweenService = game:GetService('TweenService')
local HttpService = game:GetService('HttpService')
local CoreGui = game:GetService('CoreGui')

local Mouse = LocalPlayer:GetMouse();


local Library = {
	connections = {};
    Flags = {};
    Enabled = true;
    slider_drag = false;
    core = nil;
    dragging = false;
    drag_position = nil;
    start_position = nil;
}


if not isfolder("cac hub") then
    makefolder("cac hub")
end

function Library:disconnect()
	for _, value in Library.connections do
		if not Library.connections[value] then
          continue
		end

		Library.connections[value]:Disconnect()
		Library.connections[value] = nil
	end
end

function Library:clear()
	for _, object in CoreGui:GetChildren() do
		if object.Name ~= "cac" then
           continue
		end
	
		object:Destroy()
	end
end

function Library:exist()
    if not Library.core then return end
    if not Library.core.Parent then return end
    return true
end

function Library:save_flags()
    if not Library.exist() then return end

    local flags = HttpService:JSONEncode(Library.Flags)
   writefile(`cac hub/{game.GameId}.lua`, flags)
end

function Library:load_flags()
    if not isfile(`cac hub/{game.GameId}.lua`) then Library.save_flags() return end

    local flags = readfile(`cac hub/{game.GameId}.lua`)
    if not flags then Library.save_flags() return end

    Library.Flags = HttpService:JSONDecode(flags)
end

Library.load_flags()
Library.clear()

function Library:open()
	self.Container.Visible = true
	self.Shadow.Visible = true
	self.Mobile.Modal = true

	TweenService:Create(self.Container, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
		Size = UDim2.new(0, 699, 0, 426)
	}):Play()

	TweenService:Create(self.Shadow, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
		Size = UDim2.new(0, 776, 0, 509)
	}):Play()
end

function Library:close()
	TweenService:Create(self.Shadow, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
		Size = UDim2.new(0, 0, 0, 0)
	}):Play()

	local main_tween = TweenService:Create(self.Container, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
		Size = UDim2.new(0, 0, 0, 0)
	})

	main_tween:Play()
	main_tween.Completed:Once(function()
		if Library.enabled then
			return
		end

		self.Container.Visible = false
		self.Shadow.Visible = false
		self.Mobile.Modal = false
	end)
end

function Library:drag()
	if not Library.drag_position then
		return
	end
	
	if not Library.start_position then
		return
	end
	
	local delta = self.input.Position - Library.drag_position
	local position = UDim2.new(Library.start_position.X.Scale, Library.start_position.X.Offset + delta.X, Library.start_position.Y.Scale, Library.start_position.Y.Offset + delta.Y)

	TweenService:Create(self.container.Container, TweenInfo.new(0.2), {
		Position = position
	}):Play()

    TweenService:Create(self.container.Shadow, TweenInfo.new(0.2), {
		Position = position
	}):Play()
end

function Library:visible()
	Library.enabled = not Library.enabled

	if Library.enabled then
		Library.open(self)
	else
		Library.close(self)
	end
end

function Library:new()
	local container = Instance.new("ScreenGui")
	container.Name = "cac"
    container.Parent = CoreGui

    Library.core = container

	local Shadow = Instance.new("ImageLabel")
	Shadow.Name = "Shadow"
	Shadow.Parent = container
	Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
	Shadow.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Shadow.BackgroundTransparency = 1.000
	Shadow.BorderColor3 = Color3.fromRGB(0, 0, 0)
	Shadow.BorderSizePixel = 0
	Shadow.Position = UDim2.new(0.508668244, 0, 0.5, 0)
	Shadow.Size = UDim2.new(0, 776, 0, 509)
	Shadow.ZIndex = 0
	Shadow.Image = "rbxassetid://17290899982"

	local Container = Instance.new("Frame")
	Container.Name = "Container"
	Container.Parent = container
	Container.AnchorPoint = Vector2.new(0.5, 0.5)
	Container.BackgroundColor3 = Color3.fromRGB(19, 20, 24)
	Container.BorderColor3 = Color3.fromRGB(0, 0, 0)
	Container.BorderSizePixel = 0
	Container.ClipsDescendants = true
	Container.Position = UDim2.new(0.5, 0, 0.5, 0)
	Container.Size = UDim2.new(0, 699, 0, 426)

	local ContainerCorner = Instance.new("UICorner")
	ContainerCorner.CornerRadius = UDim.new(0, 20)
	ContainerCorner.Parent = container.Container

	local Top = Instance.new("ImageLabel")
	Top.Name = "Top"
	Top.Parent = Container
	Top.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Top.BackgroundTransparency = 1.000
	Top.BorderColor3 = Color3.fromRGB(0, 0, 0)
	Top.BorderSizePixel = 0
	Top.Size = UDim2.new(0, 699, 0, 39)
	Top.Image = ""

	local Logo = Instance.new("ImageLabel")
	Logo.Name = "Logo"
	Logo.Parent = Top
	Logo.AnchorPoint = Vector2.new(0.5, 0.5)
	Logo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Logo.BackgroundTransparency = 1.000
	Logo.BorderColor3 = Color3.fromRGB(0, 0, 0)
	Logo.BorderSizePixel = 0
	Logo.Position = UDim2.new(0.0387367606, 0, 0.5, 0)
	Logo.Size = UDim2.new(0, 30, 0, 25)
	Logo.Image = ""
	
	local TextLabel = Instance.new("TextLabel")
	TextLabel.Parent = Top
	TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.BackgroundTransparency = 1.000
	TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
	TextLabel.BorderSizePixel = 0
	TextLabel.Position = UDim2.new(0.0938254446, 0, 0.496794879, 0)
	TextLabel.Size = UDim2.new(0, 75, 0, 16)
	TextLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
	TextLabel.Text = getgenv().namehub
	TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.TextScaled = true
	TextLabel.TextSize = 14.000
	TextLabel.TextWrapped = true
	TextLabel.TextXAlignment = Enum.TextXAlignment.Left

	local Line = Instance.new("Frame")
	Line.Name = "Line"
	Line.Parent = Container
	Line.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
	Line.BorderColor3 = Color3.fromRGB(0, 0, 0)
	Line.BorderSizePixel = 0
	Line.Position = UDim2.new(0.296137333, 0, 0.0915492922, 0)
	Line.Size = UDim2.new(0, 2, 0, 387)

    local tabs = Instance.new("ScrollingFrame")
	tabs.Name = "Tabs"
	tabs.Active = true
	tabs.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	tabs.BackgroundTransparency = 1.000
	tabs.BorderColor3 = Color3.fromRGB(0, 0, 0)
	tabs.BorderSizePixel = 0
	tabs.Position = UDim2.new(0, 0, 0.0915492922, 0)
	tabs.Size = UDim2.new(0, 209, 0, 386)
	tabs.ScrollBarImageColor3 = Color3.fromRGB(0, 0, 0)
	tabs.ScrollBarThickness = 0
    tabs.Parent = container.Container

	local tabslist = Instance.new("UIListLayout")
	tabslist.Parent = tabs
	tabslist.HorizontalAlignment = Enum.HorizontalAlignment.Center
	tabslist.SortOrder = Enum.SortOrder.LayoutOrder
	tabslist.Padding = UDim.new(0, 9)

	local UIPadding = Instance.new("UIPadding")
	UIPadding.Parent = tabs
	UIPadding.PaddingTop = UDim.new(0, 15)

	local tabsCorner = Instance.new("UICorner")
	tabsCorner.Parent = tabs

    local mobile_button = Instance.new("TextButton")
	mobile_button.Name = "Mobile"
	mobile_button.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
	mobile_button.BorderColor3 = Color3.fromRGB(0, 0, 0)
	mobile_button.BorderSizePixel = 0
	mobile_button.Position = UDim2.new(0.0210955422, 0, 0.91790241, 0)
	mobile_button.Size = UDim2.new(0, 122, 0, 38)
	mobile_button.AutoButtonColor = false
	mobile_button.Modal = true
	mobile_button.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
	mobile_button.Text = ""
	mobile_button.TextColor3 = Color3.fromRGB(0, 0, 0)
	mobile_button.TextSize = 14.000
    mobile_button.Parent = container

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(0, 13)
	UICorner.Parent = mobile_button

	local shadowMobile = Instance.new("ImageLabel")
	shadowMobile.Name = "Shadow"
	shadowMobile.Parent = mobile_button
	shadowMobile.AnchorPoint = Vector2.new(0.5, 0.5)
	shadowMobile.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	shadowMobile.BackgroundTransparency = 1.000
	shadowMobile.BorderColor3 = Color3.fromRGB(0, 0, 0)
	shadowMobile.BorderSizePixel = 0
	shadowMobile.Position = UDim2.new(0.5, 0, 0.5, 0)
	shadowMobile.Size = UDim2.new(0, 144, 0, 58)
	shadowMobile.ZIndex = 0
	shadowMobile.Image = "rbxassetid://17183270335"
	shadowMobile.ImageTransparency = 0.200

	local State = Instance.new("TextLabel")
	State.Name = "State"
	State.Parent = mobile_button
	State.AnchorPoint = Vector2.new(0.5, 0.5)
	State.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	State.BackgroundTransparency = 1.000
	State.BorderColor3 = Color3.fromRGB(0, 0, 0)
	State.BorderSizePixel = 0
	State.Position = UDim2.new(0.646000028, 0, 0.5, 0)
	State.Size = UDim2.new(0, 64, 0, 15)
	State.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
	State.Text = "Open"
	State.TextColor3 = Color3.fromRGB(255, 255, 255)
	State.TextScaled = true
	State.TextSize = 14.000
	State.TextWrapped = true
	State.TextXAlignment = Enum.TextXAlignment.Left

	local Icon = Instance.new("ImageLabel")
	Icon.Name = "Icon"
	Icon.Parent = mobile_button
	Icon.AnchorPoint = Vector2.new(0.5, 0.5)
	Icon.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Icon.BackgroundTransparency = 1.000
	Icon.BorderColor3 = Color3.fromRGB(0, 0, 0)
	Icon.BorderSizePixel = 0
	Icon.Position = UDim2.new(0.268000007, 0, 0.5, 0)
	Icon.Size = UDim2.new(0, 15, 0, 15)
	Icon.Image = "rbxassetid://17183279677"
    container.Container.InputBegan:Connect(function(input: InputObject)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            Library.dragging = true
            Library.drag_position = input.Position
            Library.start_position = container.Container.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    Library.dragging = false
                    Library.drag_position = nil
                    Library.start_position = nil
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input: InputObject)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            Library.drag({
                input = input,
                container = container
            })
        end
    end)

    UserInputService.InputBegan:Connect(function(input: InputObject, process: boolean)
        if process then return end

        if not Library.exist() then return end

        if input.KeyCode == Enum.KeyCode.Insert then
            Library.visible(container)
        end
    end)

    mobile_button.MouseButton1Click:Connect(function()
        Library.visible(container)
    end)

    local Tab = {}

    function Tab:update_sections()
        self.left_section.Visible = true
        self.right_section.Visible = true

        for _, object in container.Container:GetChildren() do
            if not object.Name:find("Section") then
                continue
            end

            if object == self.left_section then 
                continue
            end

            if object == self.right_section then
                continue
            end

            object.Visible = false
        end
    end

    function Tab:open_tab()
		Tab.update_sections({
			left_section = self.left_section,
			right_section = self.right_section
		})

		TweenService:Create(self.tab.Fill, TweenInfo.new(0.4), {
			BackgroundTransparency = 0
		}):Play()

		TweenService:Create(self.tab.Glow, TweenInfo.new(0.4), {
			ImageTransparency = 0
		}):Play()

		TweenService:Create(self.tab.TextLabel, TweenInfo.new(0.4), {
			TextTransparency = 0
		}):Play()

		TweenService:Create(self.tab.Logo, TweenInfo.new(0.4), {
			ImageTransparency = 0
		}):Play()

		for _, object in tabs:GetChildren() do
			if object.Name ~= 'Tab' then
				continue
			end

			if object == self.tab then
				continue
			end

			TweenService:Create(object.Fill, TweenInfo.new(0.4), {
				BackgroundTransparency = 1
			}):Play()

			TweenService:Create(object.Glow, TweenInfo.new(0.4), {
				ImageTransparency = 1
			}):Play()
	
			TweenService:Create(object.TextLabel, TweenInfo.new(0.4), {
				TextTransparency = 0.5
			}):Play()
	
			TweenService:Create(object.Logo, TweenInfo.new(0.4), {
				ImageTransparency = 0.5
			}):Play()
		end
	end

    function Tab:create_tab()
        local tab = Instance.new("TextButton")
		tab.Name = "Tab"
		tab.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
		tab.BorderColor3 = Color3.fromRGB(0, 0, 0)
		tab.BorderSizePixel = 0
		tab.Size = UDim2.new(0, 174, 0, 40)
		tab.ZIndex = 2
		tab.AutoButtonColor = false
		tab.Font = Enum.Font.SourceSans
		tab.Text = ""
		tab.TextColor3 = Color3.fromRGB(0, 0, 0)
		tab.TextSize = 14.000
		tab.Parent = tabs

		local tabCorner = Instance.new("UICorner")
		tabCorner.CornerRadius = UDim.new(0, 5)
		tabCorner.Parent = tab

		local TextLabel = Instance.new("TextLabel")
		TextLabel.Parent = tab
		TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.BackgroundTransparency = 1.000
		TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
		TextLabel.BorderSizePixel = 0
		TextLabel.Position = UDim2.new(0.58965224, 0, 0.5, 0)
		TextLabel.Size = UDim2.new(0, 124, 0, 15)
		TextLabel.ZIndex = 3
		TextLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
		TextLabel.Text = self
		TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.TextScaled = true
		TextLabel.TextSize = 14.000
		TextLabel.TextTransparency = 0.300
		TextLabel.TextWrapped = true
		TextLabel.TextXAlignment = Enum.TextXAlignment.Left

		local Logo = Instance.new("ImageLabel")
		Logo.Name = "Logo"
		Logo.Parent = tab
		Logo.AnchorPoint = Vector2.new(0.5, 0.5)
		Logo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Logo.BackgroundTransparency = 1.000
		Logo.BorderColor3 = Color3.fromRGB(0, 0, 0)
		Logo.BorderSizePixel = 0
		Logo.Position = UDim2.new(0.130999997, 0, 0.5, 0)
		Logo.Size = UDim2.new(0, 17, 0, 17)
		Logo.ZIndex = 3
		Logo.Image = "rbxassetid://17290697757"
		Logo.ImageTransparency = 0.3001

		local Glow = Instance.new("ImageLabel")
		Glow.Name = "Glow"
		Glow.Parent = tab
		Glow.AnchorPoint = Vector2.new(0.5, 0.5)
		Glow.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Glow.BackgroundTransparency = 1.000
		Glow.BorderColor3 = Color3.fromRGB(0, 0, 0)
		Glow.BorderSizePixel = 0
		Glow.Position = UDim2.new(0.5, 0, 0.5, 0)
		Glow.Size = UDim2.new(0, 190, 0, 53)
		Glow.Image = "rbxassetid://17290723539"
		Glow.ImageTransparency = 1.000

		local Fill = Instance.new("Frame")
		Fill.Name = "Fill"
		Fill.Parent = tab
		Fill.AnchorPoint = Vector2.new(0.5, 0.5)
		Fill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Fill.BackgroundTransparency = 1.000
		Fill.BorderColor3 = Color3.fromRGB(0, 0, 0)
		Fill.BorderSizePixel = 0
		Fill.Position = UDim2.new(0.5, 0, 0.5, 0)
		Fill.Size = UDim2.new(0, 174, 0, 40)
		Fill.ZIndex = 2
		local UICorner_2 = Instance.new("UICorner")
		UICorner_2.CornerRadius = UDim.new(0, 10)
		UICorner_2.Parent = Fill

		local UIGradient = Instance.new("UIGradient")
		UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(66, 89, 182)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(37, 57, 137))}
		UIGradient.Rotation = 20
		UIGradient.Parent = Fill

		local left_section = Instance.new("ScrollingFrame")
		left_section.Name = "LeftSection"
		left_section.Active = true
		left_section.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		left_section.BackgroundTransparency = 1.000
		left_section.BorderColor3 = Color3.fromRGB(0, 0, 0)
		left_section.BorderSizePixel = 0
		left_section.Position = UDim2.new(0.326180249, 0, 0.126760557, 0)
		left_section.Size = UDim2.new(0, 215, 0, 372)
		left_section.AutomaticCanvasSize = Enum.AutomaticSize.XY
		left_section.ScrollBarImageColor3 = Color3.fromRGB(0, 0, 0)
		left_section.ScrollBarThickness = 0

		local leftsectionlist = Instance.new("UIListLayout")
		leftsectionlist.Parent = left_section
		leftsectionlist.HorizontalAlignment = Enum.HorizontalAlignment.Center
		leftsectionlist.SortOrder = Enum.SortOrder.LayoutOrder
		leftsectionlist.Padding = UDim.new(0, 7)

		local right_section = Instance.new("ScrollingFrame")
		right_section.Name = "RightSection"
		right_section.Active = true
		right_section.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		right_section.BackgroundTransparency = 1.000
		right_section.BorderColor3 = Color3.fromRGB(0, 0, 0)
		right_section.BorderSizePixel = 0
		right_section.Position = UDim2.new(0.662374794, 0, 0.126760557, 0)
		right_section.Size = UDim2.new(0, 215, 0, 372)
		right_section.AutomaticCanvasSize = Enum.AutomaticSize.XY
		right_section.ScrollBarImageColor3 = Color3.fromRGB(0, 0, 0)
		right_section.ScrollBarThickness = 0

		local rightsectionlist = Instance.new("UIListLayout")
		rightsectionlist.Parent = right_section

		rightsectionlist.HorizontalAlignment = Enum.HorizontalAlignment.Center
		rightsectionlist.SortOrder = Enum.SortOrder.LayoutOrder
		rightsectionlist.Padding = UDim.new(0, 7)

		if container.Container:FindFirstChild('RightSection') then
			left_section.Visible = false
			right_section.Visible = false
		else
			Tab.open_tab({
				tab = tab,
				left_section = left_section,
				right_section = right_section
			})
		end

		left_section.Parent = container.Container
		right_section.Parent = container.Container

		tab.MouseButton1Click:Connect(function()
			Tab.open_tab({
				tab = tab,
				left_section = left_section,
				right_section = right_section
			})
		end)

        local Module = {}

        function Module:create_title()
			local section = self.section == 'left' and left_section or right_section

			local title = Instance.new("TextLabel")
			title.Name = "Title"
			title.AnchorPoint = Vector2.new(0.5, 0.5)
			title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			title.BackgroundTransparency = 1.000
			title.BorderColor3 = Color3.fromRGB(0, 0, 0)
			title.BorderSizePixel = 0
			title.Position = UDim2.new(0.531395316, 0, 0.139784947, 0)
			title.Size = UDim2.new(0, 201, 0, 15)
			title.ZIndex = 2
			title.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			title.TextColor3 = Color3.fromRGB(255, 255, 255)
			title.TextScaled = true
			title.TextSize = 14.000
			title.TextWrapped = true
			title.TextXAlignment = Enum.TextXAlignment.Left
			title.Parent = section
			title.Text = self.name
		end

		function Module:enable_toggle()
			TweenService:Create(self.Checkbox.Fill, TweenInfo.new(0.4), {
				BackgroundTransparency = 0
			}):Play()

			TweenService:Create(self.Checkbox.Glow, TweenInfo.new(0.4), {
				ImageTransparency = 0
			}):Play()
		end

		function Module:disable_toggle()
			TweenService:Create(self.Checkbox.Fill, TweenInfo.new(0.4), {
				BackgroundTransparency = 1
			}):Play()

			TweenService:Create(self.Checkbox.Glow, TweenInfo.new(0.4), {
				ImageTransparency = 1
			}):Play()
		end

		function Module:update_toggle()
			if self.state then
				Module.enable_toggle(self.toggle)
			else
				Module.disable_toggle(self.toggle)
			end
		end
         
    function Module:create_button()
    local section = self.section == 'left' and left_section or right_section

    local button = Instance.new("TextButton")
    button.Name = "Button"
    button.Parent = section
    button.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
    button.BorderColor3 = Color3.fromRGB(0, 0, 0)
    button.BorderSizePixel = 0
    button.Size = UDim2.new(0, 215, 0, 36)
    button.AutoButtonColor = false
    button.Font = Enum.Font.SourceSans
    button.Text = self.name
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 14.000

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 10)
    UICorner.Parent = button

    button.MouseButton1Click:Connect(function()
        self.callback()
    end)
end
   
        function Module:create_toggle()
			local section = self.section == 'left' and left_section or right_section

			local toggle = Instance.new("TextButton")
			toggle.Name = "Toggle"
			toggle.Parent = section
			toggle.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
			toggle.BorderColor3 = Color3.fromRGB(0, 0, 0)
			toggle.BorderSizePixel = 0
			toggle.Size = UDim2.new(0, 215, 0, 37)
			toggle.AutoButtonColor = false
			toggle.Font = Enum.Font.SourceSans
			toggle.Text = ""
			toggle.TextColor3 = Color3.fromRGB(0, 0, 0)
			toggle.TextSize = 14.000
			local UICorner = Instance.new("UICorner")
			UICorner.CornerRadius = UDim.new(0, 10)
			UICorner.Parent = toggle
	
			local Checkbox = Instance.new("Frame")
			Checkbox.Name = "Checkbox"
			Checkbox.Parent = toggle
			Checkbox.AnchorPoint = Vector2.new(0.5, 0.5)
			Checkbox.BackgroundColor3 = Color3.fromRGB(22, 23, 27)
			Checkbox.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Checkbox.BorderSizePixel = 0
			Checkbox.Position = UDim2.new(0.915000021, 0, 0.5, 0)
			Checkbox.Size = UDim2.new(0, 17, 0, 17)		

			local UICorner_2 = Instance.new("UICorner")
			UICorner_2.CornerRadius = UDim.new(0, 4)
			UICorner_2.Parent = Checkbox

			local Glow = Instance.new("ImageLabel")
			Glow.Name = "Glow"
			Glow.Parent = Checkbox
			Glow.AnchorPoint = Vector2.new(0.5, 0.5)
			Glow.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Glow.BackgroundTransparency = 1.000
			Glow.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Glow.BorderSizePixel = 0
			Glow.Position = UDim2.new(0.5, 0, 0.5, 0)
			Glow.Size = UDim2.new(0, 27, 0, 27)
			Glow.Image = "rbxassetid://17290798394"
			Glow.ImageTransparency = 1.000

			local Fill = Instance.new("Frame")
			Fill.Name = "Fill"
			Fill.Parent = Checkbox
			Fill.AnchorPoint = Vector2.new(0.5, 0.5)
			Fill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Fill.BackgroundTransparency = 1.000
			Fill.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Fill.BorderSizePixel = 0
			Fill.Position = UDim2.new(0.5, 0, 0.5, 0)
			Fill.Size = UDim2.new(0, 17, 0, 17)

			local UICorner_3 = Instance.new("UICorner")
			UICorner_3.CornerRadius = UDim.new(0, 4)
			UICorner_3.Parent = Fill

			local UIGradient = Instance.new("UIGradient")
			UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(66, 89, 182)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(37, 57, 137))}
			UIGradient.Rotation = 20
			UIGradient.Parent = Fill

			local TextLabel = Instance.new("TextLabel")
			TextLabel.Parent = toggle
			TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.BackgroundTransparency = 1.000
			TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			TextLabel.BorderSizePixel = 0
			TextLabel.Position = UDim2.new(0.444953382, 0, 0.5, 0)
			TextLabel.Size = UDim2.new(0, 164, 0, 15)
			TextLabel.ZIndex = 2
			TextLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.TextScaled = true
			TextLabel.TextSize = 14.000
			TextLabel.TextWrapped = true
			TextLabel.TextXAlignment = Enum.TextXAlignment.Left
			TextLabel.Text = self.name

			if not Library.Flags[self.flag] then
				Library.Flags[self.flag] = self.enabled
			end

			self.callback(Library.Flags[self.flag])
			
			Module.update_toggle({
				state = Library.Flags[self.flag],
				toggle = toggle
			})

			toggle.MouseButton1Click:Connect(function()
				Library.Flags[self.flag] = not Library.Flags[self.flag]
				Library.save_flags()

				Module.update_toggle({
					state = Library.Flags[self.flag],
					toggle = toggle
				})

				self.callback(Library.Flags[self.flag])
			end)
		end


        function Module:update_slider()
			local result = math.clamp((Mouse.X - self.slider.Box.AbsolutePosition.X) / self.slider.Box.AbsoluteSize.X, 0, 1)

			if not result then
				return
			end

			local number = math.floor(((self.maximum_value - self.minimum_value) * result) + self.minimum_value)
			local slider_size = math.clamp(result, 0.001, 0.999)
			
			self.slider.Box.Fill.UIGradient.Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(slider_size, 0),
				NumberSequenceKeypoint.new(math.min(slider_size + 0.001, 1), 1),
				NumberSequenceKeypoint.new(1, 1)
			})
			
			self.slider.Box.Glow.UIGradient.Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(slider_size, 0),
				NumberSequenceKeypoint.new(math.min(slider_size + 0.03, 1), 1),
				NumberSequenceKeypoint.new(1, 1)
			})

			Library.Flags[self.flag] = number

			self.slider.Number.Text = number
			self.callback(number)
		end

		function Module:slider_loop()
			Library.slider_drag = true
			
			while Library.slider_drag do
				Module.update_slider(self)
				
				task.wait()
			end
		end


        function Module:create_slider()
			local drag = false
			local section = self.section == 'left' and left_section or right_section

			local slider = Instance.new("TextButton")
			slider.Name = "Slider"
			slider.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
			slider.BorderColor3 = Color3.fromRGB(0, 0, 0)
			slider.BorderSizePixel = 0
			slider.Size = UDim2.new(0, 215, 0, 48)
			slider.AutoButtonColor = false
			slider.Font = Enum.Font.SourceSans
			slider.Text = ""
			slider.TextColor3 = Color3.fromRGB(0, 0, 0)
			slider.TextSize = 14.000
			slider.Parent = section

			local UICorner = Instance.new("UICorner")
			UICorner.CornerRadius = UDim.new(0, 10)
			UICorner.Parent = slider

			local Box = Instance.new("Frame")
			Box.Name = "Box"
			Box.Parent = slider
			Box.AnchorPoint = Vector2.new(0.5, 0.5)
			Box.BackgroundColor3 = Color3.fromRGB(22, 23, 27)
			Box.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Box.BorderSizePixel = 0
			Box.Position = UDim2.new(0.508023143, 0, 0.708333313, 0)
			Box.Size = UDim2.new(0, 192, 0, 6)

			local UICorner_2 = Instance.new("UICorner")
			UICorner_2.CornerRadius = UDim.new(0, 15)
			UICorner_2.Parent = Box

			local Glow = Instance.new("ImageLabel")
			Glow.Name = "Glow"
			Glow.Parent = Box
			Glow.AnchorPoint = Vector2.new(0.5, 0.5)
			Glow.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Glow.BackgroundTransparency = 1.000
			Glow.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Glow.BorderSizePixel = 0
			Glow.Position = UDim2.new(0.5, 0, 0.5, 0)
			Glow.Size = UDim2.new(0, 204, 0, 17)
			Glow.ZIndex = 2
			Glow.Image = "rbxassetid://17381990533"

			local UIGradient = Instance.new("UIGradient")
			UIGradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0.00, 0.00), NumberSequenceKeypoint.new(0.50, 0.00), NumberSequenceKeypoint.new(0.53, 1.00), NumberSequenceKeypoint.new(1.00, 1.00)}
			UIGradient.Parent = Glow

			local Fill = Instance.new("ImageLabel")
			Fill.Name = "Fill"
			Fill.Parent = Box
			Fill.AnchorPoint = Vector2.new(0, 0.5)
			Fill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Fill.BackgroundTransparency = 1.000
			Fill.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Fill.BorderSizePixel = 0
			Fill.Position = UDim2.new(0, 0, 0.5, 0)
			Fill.Size = UDim2.new(0, 192, 0, 6)
			Fill.Image = "rbxassetid://17382033116"

			local UICorner_3 = Instance.new("UICorner")
			UICorner_3.CornerRadius = UDim.new(0, 4)
			UICorner_3.Parent = Fill

			local UIGradient_2 = Instance.new("UIGradient")
			UIGradient_2.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0.00, 0.00), NumberSequenceKeypoint.new(0.50, 0.00), NumberSequenceKeypoint.new(0.50, 1.00), NumberSequenceKeypoint.new(1.00, 1.00)}
			UIGradient_2.Parent = Fill
			
			local Hitbox = Instance.new("TextButton")
			Hitbox.Name = "Hitbox"
			Hitbox.Parent = Box
			Hitbox.AnchorPoint = Vector2.new(0.5, 0.5)
			Hitbox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Hitbox.BackgroundTransparency = 1.000
			Hitbox.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Hitbox.BorderSizePixel = 0
			Hitbox.Position = UDim2.new(0.5, 0, 0.5, 0)
			Hitbox.Size = UDim2.new(0, 200, 0, 13)
			Hitbox.ZIndex = 3
			Hitbox.AutoButtonColor = false
			Hitbox.Font = Enum.Font.SourceSans
			Hitbox.Text = ""
			Hitbox.TextColor3 = Color3.fromRGB(0, 0, 0)
			Hitbox.TextSize = 14.000

			local TextLabel = Instance.new("TextLabel")
			TextLabel.Parent = slider
			TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.BackgroundTransparency = 1.000
			TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			TextLabel.BorderSizePixel = 0
			TextLabel.Position = UDim2.new(0.414720833, 0, 0.375, 0)
			TextLabel.Size = UDim2.new(0, 151, 0, 15)
			TextLabel.ZIndex = 2
			TextLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.TextScaled = true
			TextLabel.TextSize = 14.000
			TextLabel.TextWrapped = true
			TextLabel.TextXAlignment = Enum.TextXAlignment.Left

			local Number = Instance.new("TextLabel")
			Number.Name = "Number"
			Number.Parent = slider
			Number.AnchorPoint = Vector2.new(0.5, 0.5)
			Number.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Number.BackgroundTransparency = 1.000
			Number.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Number.BorderSizePixel = 0
			Number.Position = UDim2.new(0.854255736, 0, 0.375, 0)
			Number.Size = UDim2.new(0, 38, 0, 15)
			Number.ZIndex = 2
			Number.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			Number.TextColor3 = Color3.fromRGB(255, 255, 255)
			Number.TextScaled = true
			Number.TextSize = 14.000
			Number.TextWrapped = true
			Number.TextXAlignment = Enum.TextXAlignment.Right


			TextLabel.Text = self.name
			Number.Text = self.value

			if not Library.Flags[self.flag] then
				Library.Flags[self.flag] = self.value
			end

			slider.Number.Text = Library.Flags[self.flag]
			self.callback(Library.Flags[self.flag])

			slider.Box.Hitbox.MouseButton1Down:Connect(function()
				if Library.slider_drag then
					return
				end

				Module.slider_loop({
					slider = slider,
					flag = self.flag,
					callback = self.callback,

					maximum_value = self.maximum_value,
					minimum_value = self.minimum_value,
				})
			end)
			
			UserInputService.InputEnded:Connect(function(input: InputObject, process: boolean)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					Library.slider_drag = false
					Library.save_flags()
				end
			end)
		end

        function Module:create_dropdown()
			local section = self.section == 'left' and left_section or right_section
			local list_size = 6
			local open = false

			local option = Instance.new("TextButton")
			option.Name = "Option"
			option.Active = false
			option.AnchorPoint = Vector2.new(0.5, 0.5)
			option.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			option.BackgroundTransparency = 1.000
			option.BorderColor3 = Color3.fromRGB(0, 0, 0)
			option.BorderSizePixel = 0
			option.Position = UDim2.new(0.47283414, 0, 0.309523821, 0)
			option.Selectable = false
			option.Size = UDim2.new(0, 176, 0, 13)
			option.ZIndex = 2
			option.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			option.TextColor3 = Color3.fromRGB(255, 255, 255)
			option.TextScaled = true
			option.TextSize = 14.000
			option.TextTransparency = 0.500
			option.TextWrapped = true
			option.TextXAlignment = Enum.TextXAlignment.Left

			local dropdown = Instance.new("TextButton")
			dropdown.Parent = section
			dropdown.Name = "Dropdown"
			dropdown.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
			dropdown.BorderColor3 = Color3.fromRGB(0, 0, 0)
			dropdown.BorderSizePixel = 0
			dropdown.Size = UDim2.new(0, 215, 0, 36)
			dropdown.AutoButtonColor = false
			dropdown.Font = Enum.Font.SourceSans
			dropdown.Text = ""
			dropdown.TextColor3 = Color3.fromRGB(0, 0, 0)
			dropdown.TextSize = 14.000

			local UICorner = Instance.new("UICorner")
			UICorner.CornerRadius = UDim.new(0, 10)
			UICorner.Parent = dropdown

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Parent = dropdown
			UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			
			local UIPadding = Instance.new("UIPadding")
			UIPadding.Parent = dropdown
			UIPadding.PaddingTop = UDim.new(0, 6)
			
			local Box = Instance.new("Frame")
			Box.Name = "Box"
			Box.Parent = dropdown
			Box.AnchorPoint = Vector2.new(0.5, 0)
			Box.BackgroundColor3 = Color3.fromRGB(22, 23, 27)
			Box.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Box.BorderSizePixel = 0
			Box.Position = UDim2.new(0.5, 0, 0.150000006, 0)
			Box.Size = UDim2.new(0, 202, 0, 25)
			Box.ZIndex = 2

			local UICorner_2 = Instance.new("UICorner")
			UICorner_2.CornerRadius = UDim.new(0, 6)
			UICorner_2.Parent = Box

			local Options = Instance.new("Frame")
			Options.Name = "Options"
			Options.Parent = Box
			Options.AnchorPoint = Vector2.new(0.5, 0)
			Options.BackgroundColor3 = Color3.fromRGB(22, 23, 27)
			Options.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Options.BorderSizePixel = 0
			Options.ClipsDescendants = true
			Options.Position = UDim2.new(0.5, 0, 0.75999999, 0)
			Options.Size = UDim2.new(0, 202, 0, 0)

			local UICorner_3 = Instance.new("UICorner")
			UICorner_3.CornerRadius = UDim.new(0, 6)
			UICorner_3.Parent = Options

			local UIPadding_2 = Instance.new("UIPadding")
			UIPadding_2.Parent = Options
			UIPadding_2.PaddingLeft = UDim.new(0, 15)
			UIPadding_2.PaddingTop = UDim.new(0, 10)

			local UIListLayout_2 = Instance.new("UIListLayout")
			UIListLayout_2.Parent = Options
			UIListLayout_2.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout_2.Padding = UDim.new(0, 10)

			local TextLabel = Instance.new("TextLabel")
			TextLabel.Parent = Box
			TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.BackgroundTransparency = 1.000
			TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			TextLabel.BorderSizePixel = 0
			TextLabel.Position = UDim2.new(0.430000007, 0, 0.5, 0)
			TextLabel.Size = UDim2.new(0, 151, 0, 13)
			TextLabel.ZIndex = 2
			TextLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.TextScaled = true
			TextLabel.TextSize = 14.000
			TextLabel.TextWrapped = true
			TextLabel.TextXAlignment = Enum.TextXAlignment.Left

			local Arrow = Instance.new("ImageLabel")
			Arrow.Name = "Arrow"
			Arrow.Parent = Box
			Arrow.Active = true
			Arrow.AnchorPoint = Vector2.new(0.5, 0.5)
			Arrow.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Arrow.BackgroundTransparency = 1.000
			Arrow.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Arrow.BorderSizePixel = 0
			Arrow.Position = UDim2.new(0.920000017, 0, 0.5, 0)
			Arrow.Size = UDim2.new(0, 12, 0, 12)
			Arrow.ZIndex = 2
			Arrow.Image = "rbxassetid://17400678941"

			dropdown.Box.TextLabel.Text = self.name

			local Dropdown = {}

			function Dropdown:open()
				dropdown.Box.TextLabel.Text = Library.Flags[self.flag]

				TweenService:Create(dropdown.Box.Options, TweenInfo.new(0.4), {
					Size = UDim2.new(0, 202, 0, list_size)
				}):Play()

				TweenService:Create(dropdown, TweenInfo.new(0.4), {
					Size = UDim2.new(0, 215, 0, 30 + list_size)
				}):Play()

				TweenService:Create(dropdown.Box.Arrow, TweenInfo.new(0.4), {
					Rotation = 180
				}):Play()
			end
			
			function Dropdown:close()
				dropdown.Box.TextLabel.Text = self.name
				TweenService:Create(dropdown.Box.Options, TweenInfo.new(0.4), {
					Size = UDim2.new(0, 202, 0, 0)
				}):Play()

				TweenService:Create(dropdown, TweenInfo.new(0.4), {
					Size = UDim2.new(0, 215, 0, 36)
				}):Play()

				TweenService:Create(dropdown.Box.Arrow, TweenInfo.new(0.4), {
					Rotation = 0
				}):Play()
			end

			function Dropdown:clear()
				for _, object in dropdown.Box.Options:GetChildren() do
					if object.Name ~= 'Option' then
						continue
					end

					object:Destroy()
				end
			end

			function Dropdown:select_option()
				TweenService:Create(self.new_option, TweenInfo.new(0.4), {
					TextTransparency = 0
				}):Play()

				for _, object in dropdown.Box.Options:GetChildren() do
					if object.Name ~= 'Option' then
						continue
					end

					if object.Text == Library.Flags[self.flag] then
						continue
					end

					TweenService:Create(object, TweenInfo.new(0.4), {
						TextTransparency = 0.5
					}):Play()
				end

				dropdown.Box.TextLabel.Text = self.new_option.Text
			end

			function Dropdown:update()
				Dropdown.clear()

				for _, value in self.options do
					list_size += 23

					local new_option = option:Clone()
					new_option.Parent = dropdown.Box.Options
					new_option.Text = value
	
					if value == Library.Flags[self.flag] then
						new_option.TextTransparency = 0
					end
	
					new_option.MouseButton1Click:Connect(function()
						Library.Flags[self.flag] = value
						
						if list_open then
							dropdown.Box.TextLabel.Text = Library.Flags[self.flag]
						end
						self.callback(Library.Flags[self.flag])
						Library.save_flags()

						Dropdown.select_option({
							new_option = new_option,
							flag = self.flag
						})
					end)
				end
			end

			if not Library.Flags[self.flag] then
				Library.Flags[self.flag] = self.option
			end
			
			self.callback(Library.Flags[self.flag])
			Dropdown.update(self)

			dropdown.MouseButton1Click:Connect(function()
				open = not open

				if open then
					Dropdown.open(self)
				else
					Dropdown.close(self)
				end
			end)

			return Dropdown
		end

        function Module:create_textbox()
            local section = self.section == 'left' and left_section or right_section
			local Textbox = {}
            local textbox = Instance.new("TextButton")
			textbox.Name = "TextBox"
			textbox.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
			textbox.BorderColor3 = Color3.fromRGB(0, 0, 0)
			textbox.BorderSizePixel = 0
			textbox.Size = UDim2.new(0, 215, 0, 36)
			textbox.AutoButtonColor = false
			textbox.Font = Enum.Font.SourceSans
			textbox.Text = ""
			textbox.TextColor3 = Color3.fromRGB(0, 0, 0)
			textbox.TextSize = 14.000				
            textbox.Parent = section

			local UICorner = Instance.new("UICorner")
			UICorner.CornerRadius = UDim.new(0, 10)
			UICorner.Parent = textbox

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Parent = textbox
			UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

			local UIPadding = Instance.new("UIPadding")
			UIPadding.Parent = textbox
			UIPadding.PaddingTop = UDim.new(0, 6)
			
			local Box = Instance.new("Frame")
			Box.Name = "Box"
			Box.Parent = textbox
			Box.AnchorPoint = Vector2.new(0.5, 0)
			Box.BackgroundColor3 = Color3.fromRGB(22, 23, 27)
			Box.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Box.BorderSizePixel = 0
			Box.Position = UDim2.new(0.5, 0, 0.150000006, 0)
			Box.Size = UDim2.new(0, 202, 0, 25)
			Box.ZIndex = 2

			
			local UICorner_2 = Instance.new("UICorner")
			UICorner_2.CornerRadius = UDim.new(0, 6)
			UICorner_2.Parent = Box

			local TextHolder = Instance.new("TextBox")
			TextHolder.Name = "TextHolder"
			TextHolder.Parent = Box
			TextHolder.BackgroundColor3 = Color3.fromRGB(22, 23, 27)
			TextHolder.BorderColor3 = Color3.fromRGB(0, 0, 0)
			TextHolder.BorderSizePixel = 0
			TextHolder.Position = UDim2.new(0.0445544571, 0, 0.239999995, 0)
			TextHolder.Size = UDim2.new(0, 182, 0, 13)
			TextHolder.ZIndex = 2
			TextHolder.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			TextHolder.Text = ""
			TextHolder.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextHolder.TextSize = 14.000
			TextHolder.TextXAlignment = Enum.TextXAlignment.Left
			textbox.Box.TextHolder.PlaceholderText = self.name

			if not Library.Flags[self.flag] then
				Library.Flags[self.flag] = self.value
			else
				textbox.Box.TextHolder.Text = Library.Flags[self.flag]
			end

			self.callback(Library.Flags[self.flag])
			textbox.Box.TextHolder.FocusLost:Connect(function()
				self.callback(textbox.Box.TextHolder.Text)
				Library.save_flags()
			end)

			function Textbox:update(text)
				textbox.Box.TextHolder.Text = text
				self.callback(text)
			end

            return Textbox;
        end
		function Module:create_keybind()
			local section = self.section == 'left' and left_section or right_section
			local keybind = Instance.new("TextButton")
			keybind.Name = "Keybind"
			keybind.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
			keybind.BorderColor3 = Color3.fromRGB(0, 0, 0)
			keybind.BorderSizePixel = 0
			keybind.Position = UDim2.new(-0.0186046511, 0, 0.440860212, 0)
			keybind.Size = UDim2.new(0, 215, 0, 37)
			keybind.AutoButtonColor = false
			keybind.Font = Enum.Font.SourceSans
			keybind.Text = ""
			keybind.TextColor3 = Color3.fromRGB(0, 0, 0)
			keybind.TextSize = 14.000
			keybind.Parent = section

			local UICorner = Instance.new("UICorner")

			UICorner.CornerRadius = UDim.new(0, 10)
			UICorner.Parent = keybind
			
			local TextLabel = Instance.new("TextLabel")
			TextLabel.Parent = keybind
			TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.BackgroundTransparency = 1.000
			TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			TextLabel.BorderSizePixel = 0
			TextLabel.Position = UDim2.new(0.424475819, 0, 0.5, 0)
			TextLabel.Size = UDim2.new(0, 155, 0, 15)
			TextLabel.ZIndex = 2
			TextLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.TextScaled = true
			TextLabel.TextSize = 14.000
			TextLabel.TextWrapped = true
			TextLabel.TextXAlignment = Enum.TextXAlignment.Left

			local Box = Instance.new("Frame")
			Box.Name = "Box"
			Box.Parent = keybind
			Box.AnchorPoint = Vector2.new(0.5, 0.5)
			Box.BackgroundColor3 = Color3.fromRGB(22, 23, 27)
			Box.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Box.BorderSizePixel = 0
			Box.Position = UDim2.new(0.875459313, 0, 0.472972959, 0)
			Box.Size = UDim2.new(0, 27, 0, 21)

			local UICorner_2 = Instance.new("UICorner")
			UICorner_2.CornerRadius = UDim.new(0, 4)
			UICorner_2.Parent = Box

			
			local TextLabel_2 = Instance.new("TextLabel")
			TextLabel_2.Parent = Box
			TextLabel_2.AnchorPoint = Vector2.new(0.5, 0.5)
			TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel_2.BackgroundTransparency = 1.000
			TextLabel_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
			TextLabel_2.BorderSizePixel = 0
			TextLabel_2.Position = UDim2.new(0.630466938, 0, 0.5, 0)
			TextLabel_2.Size = UDim2.new(0, 29, 0, 15)
			TextLabel_2.ZIndex = 2
			TextLabel_2.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
			TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel_2.TextScaled = true
			TextLabel_2.TextSize = 14.000
			TextLabel_2.TextWrapped = true

			keybind.TextLabel.Text = self.name
			keybind.Box.TextLabel.Text = self.keycode.Name

			if not Library.Flags[self.flag] then
				Library.Flags[self.flag] = self.keycode.Name
			end

			keybind.MouseButton1Click:Connect(function()
				keybind.Box.TextLabel.Text = '...'
				local a,b = UserInputService.InputBegan:Wait();
				if a.KeyCode.Name ~= 'Unknown' then
					keybind.Box.TextLabel.Text = a.KeyCode.Name
					Library.Flags[self.flag] = a.KeyCode.Name
					Library.save_flags()
				end
			end)

			UserInputService.InputBegan:Connect(function(current, pressed)
				if not pressed then
					if current.KeyCode.Name == Library.Flags[self.flag] then
						self.callback(Library.Flags[self.flag])
					end
				end
			end)
		end
        return Module
    end
    return Tab
end


-- Services & Utils
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local function bodytp(cf)
    local hrp = (game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1/0, 1/0, 1/0)
    bv.Velocity = Vector3.zero
    bv.Parent = hrp
    local fin = false
    local con
    con = game:GetService("RunService").Heartbeat:Connect(function()
        local dir = (cf.Position - hrp.Position)
        if dir.Magnitude < 2 and bv.Velocity == Vector3.zero then
            bv.Velocity = Vector3.zero
            hrp.CFrame = cf
            con:Disconnect()
            bv:Destroy()
            fin = true
        else
            bv.Velocity = dir.Unit * 35
        end
    end)
    repeat task.wait() until fin
end

-- Script Init

local Lib = Library.new()
local home = Lib.create_tab('Home')
local main = Lib.create_tab('Main')
local esp = Lib.create_tab('ESP')
local teleport = Lib.create_tab('Teleport')
local webhook = Lib.create_tab('Webhook')
local utility = Lib.create_tab('Utility')
local shop = Lib.create_tab('Shop')
local server = Lib.create_tab('Server')
local settings = Lib.create_tab('Settings')

 

home.create_title({
	name = 'Credits: Steal A BrainRot Moondiety',
	section = 'left'
})

home.create_button({
    name = 'Join Discord like a GOOD BOY',
    section = 'left',
    callback = function()
        setclipboard('https://discord.gg/moondiety')
    end
})




local Players = game:GetService("Players")
local player = Players.LocalPlayer

local godMode = true 
local godConnection = nil

-- God Mode Logic
local function toggleGodMode()
    local char = player.Character
    if not char then return end

    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    if godConnection then
        godConnection:Disconnect()
        godConnection = nil
    end

    if godMode then
        hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
        hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)

        godConnection = hum.StateChanged:Connect(function(_, newState)
            if newState == Enum.HumanoidStateType.Dead then
                hum:ChangeState(Enum.HumanoidStateType.Running)
            end
        end)
    else
        hum:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
    end
end

-- UI Toggle in Tab.Main
main.create_toggle({
	name = 'God Mode',
	flag = 'godmode',
	section = 'left',
	enabled = true,
	callback = function(state)
		godMode = state
		toggleGodMode()
	end
})


-- === WALK SPEED ===
-- === MAIN TAB ===
local player = game:GetService("Players").LocalPlayer
local donetools = {}
local active = false


local function spamTool(tool)
    if tool:IsA("Tool") and not donetools[tool] then
        donetools[tool] = true
        coroutine.wrap(function()
            while active do
                task.wait()
                pcall(function()
                    if tool.Parent == player.Character or tool.Parent == player.Backpack then
                        tool.Parent = player.Character
                        tool:Activate()
                    end
                end)
            end
        end)()
    end
end


local function setupChar(character)
    donetools = {} 
    for _, v in pairs(character:GetChildren()) do
        spamTool(v)
    end
    character.ChildAdded:Connect(spamTool)
end


utility.create_toggle({
	name = 'Auto Hit',
	flag = 'autohit',
	section = 'left',
	enabled = false,
	callback = function(state)
		active = state
		if active and player.Character then
			setupChar(player.Character)
		end
	end
})


player.CharacterAdded:Connect(function(char)
    if active then
        setupChar(char)
    end
end)


local player = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local currentSpeed = 0

local function sSpeed(character)
    local hum = character:WaitForChild("Humanoid")
    local hb = RunService.Heartbeat
    task.spawn(function()
        while character and hum and hum.Parent do
            if currentSpeed > 0 and hum.MoveDirection.Magnitude > 0 then
                character:TranslateBy(hum.MoveDirection * currentSpeed * hb:Wait())
            end
            task.wait()
        end
    end)
end

local function onCharacterAdded(character)
    sSpeed(character)
end

player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
    onCharacterAdded(player.Character)
end

main.create_slider({
	name = 'Speed Boost',
	flag = 'speedboost',
	section = 'right',
	value = 5,
	minimum_value = 1,
	maximum_value = 15,
	callback = function(value)
		currentSpeed = value
	end
})



local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local buyRemote = ReplicatedStorage.Packages.Net["RF/CoinsShopService/RequestBuy"]

local charConn = nil
local speedBoostEnabled = false

local function equipSpeedCoil()
	local backpack = player:FindFirstChild("Backpack")
	local char = player.Character
	if not (backpack and char) then return end

	local item = backpack:FindFirstChild("Speed Coil") or char:FindFirstChild("Speed Coil")
	if not item then
		pcall(function() buyRemote:InvokeServer("Speed Coil") end)
		item = backpack:WaitForChild("Speed Coil", 2)
	end
	if not item then return end

	item.Parent = char
end

local function enableBypassSpeed()
	if charConn then charConn:Disconnect() end
	charConn = player.CharacterAdded:Connect(equipSpeedCoil)
	if player.Character then equipSpeedCoil() end
end

local function disableBypassSpeed()
	if charConn then charConn:Disconnect() end
	charConn = nil
end


main.create_toggle({
	name = 'Speed Boost v2',
	flag = 'speedboostv2',
	section = 'left',
	enabled = false,
	callback = function(state)
		speedBoostEnabled = state
		if state then
			enableBypassSpeed()
		else
			disableBypassSpeed()
		end
	end
})




_G.Min = 0
_G.Max = 1500
_G.Mut = {}
_G.Rar = {}

local function conversor(x)
        x = tostring(x):gsub(",", ""):lower()
        local n, s = x:match("([%d%.]+)([kmb]?)")
        n = tonumber(n)
        if not n then
            return nil
        end
        if s == "k" then
            n = n * 1e3
        end
        if s == "m" then
            n = n * 1e6
        end
        if s == "b" then
            n = n * 1e9
        end
        return n
    end

local function splitCSV(str)
	local t = {}
	for v in string.gmatch(str, '([^,]+)') do
		t[#t+1] = v:lower():gsub("^%s*(.-)%s*$", "%1") -- trim e lower
	end
	return t
end

local function sm(n)
	n = n:lower()
	for _, v in ipairs(_G.Mut or {}) do
		if v:find(n, 1, true) then return true end
	end
	return false
end

local function sr(n)
	n = n:lower()
	for _, v in ipairs(_G.Rar or {}) do
		if v:find(n, 1, true) then return true end
	end
	return false
end

main.create_textbox({
	name = "Minimum BrainRot Price",
	flag = "min_brainrot_price",
	section = "left",
	value = tostring(_G.Min),
	callback = function(v)
		_G.Min = tonumber(v) or 0
	end
})

main.create_textbox({
	name = "Maximum BrainRot Price",
	flag = "max_brainrot_price",
	section = "left",
	value = tostring(_G.Max),
	callback = function(v)
		_G.Max = tonumber(v) or 1500
	end
})

main.create_textbox({
	name = "Mutations (comma separated)",
	flag = "mutations",
	section = "left",
	value = "",
	callback = function(v)
		_G.Mut = splitCSV(v)
	end
})

main.create_textbox({
	name = "Rarities (comma separated)",
	flag = "rarities",
	section = "left",
	value = "",
	callback = function(v)
		_G.Rar = splitCSV(v)
	end
})

main.create_toggle({
	name = "Auto Buy BrainRots",
	flag = "autobuy_brainrots",
	section = "left",
	enabled = false,
	callback = function(e)
		_G.ABuy = e
		if e then
			task.spawn(function()
				while _G.ABuy do
					task.wait(10)
					pcall(function()
						if bodytp then
							bodytp(CFrame.new(-410.522003,-6.50197983,111.718842,0.998981535,0,-0.0451212265,0,1,0,0.0451212265,0,0.998981535))
						end
					end)

					local ma = game.Workspace:FindFirstChild("MovingAnimals")
					if ma then
						for _, a in ipairs(ma:GetDescendants()) do
							local h = a:FindFirstChild("HumanoidRootPart")
							local i = h and h:FindFirstChild("Info")
							local o = i and i:FindFirstChild("AnimalOverhead")
							if not (h and i and o) then continue end

							local p = o:FindFirstChild("Price")
							local pt = p and p.Text
							local pr = pt and conversor and conversor(pt)
							if pr and _G.Min and _G.Max and pr > _G.Min and pr < _G.Max then
								local att = h:FindFirstChild("PromptAttachment")
								local pp = att and att:FindFirstChild("ProximityPrompt")
								if pp then pcall(function() fireproximityprompt(pp) end) end
							end

							local m = o:FindFirstChild("Mutation")
							local mt = m and m.Text
							if mt and sm(mt) then
								local att = h:FindFirstChild("PromptAttachment")
								local pp = att and att:FindFirstChild("ProximityPrompt")
								if pp then pcall(function() fireproximityprompt(pp) end) end
							end

							local r = o:FindFirstChild("Rarity")
							local rt = r and r.Text
							if rt and sr(rt) then
								local att = h:FindFirstChild("PromptAttachment")
								local pp = att and att:FindFirstChild("ProximityPrompt")
								if pp then pcall(function() fireproximityprompt(pp) end) end
							end
						end
					end
				end
			end)
		end
	end
})


main.create_button({
	name = 'Steal BrainRot',
	section = 'left',

	callback = function()
		local hrp = (game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
		local cam = game:GetService("Workspace").CurrentCamera
		local backup_cframe = hrp.CFrame + Vector3.new(0, 55, 0)
		local intp = false
		local lasttp_timer = 0

		local function toroof()
			if intp or tick() - lasttp_timer < 3 then return end
			intp = true
			lasttp_timer = tick()
			local goalcf = hrp.CFrame + Vector3.new(0, 55, 0)
			cam.CameraType = Enum.CameraType.Scriptable
			cam.CFrame = goalcf
			local void = hrp.CFrame + Vector3.new(0, -450000, 0)
			for _ = 1, 5 do
				task.spawn(function()
					hrp.CFrame = goalcf
					task.wait(0.1)
					hrp.CFrame = void
					task.wait(0.1)
					hrp.CFrame = goalcf
				end)
			end
			task.wait(0.5)
			cam.CameraType = Enum.CameraType.Custom
			intp = false
		end

		task.wait(2)
		while true do
			local dist = (hrp.Position - backup_cframe.Position).Magnitude
			if dist > 10 then
				toroof()
			else
				break
			end
			task.wait(3)
		end
		braincollect()
	end
})


main.create_button({
	name = 'Teleport to Roof',
	section = 'left',

	callback = function()
		local hrp = (game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
		local cam = game:GetService("Workspace").CurrentCamera
		local intp = false
		local lasttp_timer = 0
		if intp then return end
		if tick() - lasttp_timer < 3 then return end
		intp = true
		lasttp_timer = tick()
		local goalcf = hrp.CFrame + Vector3.new(0, 55, 0)
		cam.CameraType = Enum.CameraType.Scriptable
		cam.CFrame = goalcf
		local void = hrp.CFrame + Vector3.new(0, -400000, 0)
		for _ = 1, 5 do
			task.spawn(function()
				hrp.CFrame = goalcf
				task.wait(0.1)
				hrp.CFrame = void
				task.wait(0.1)
				hrp.CFrame = goalcf
			end)
		end
		task.wait(0.5)
		cam.CameraType = Enum.CameraType.Custom
		intp = false
	end
})

main.create_toggle({
	name = 'Tween to Base',
	flag = 'tweentobase',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			local base = nil
			for _, plot in pairs(workspace.Plots:GetChildren()) do
				local yourBase = plot:FindFirstChild("YourBase", true)
				if yourBase and yourBase.Enabled then
					base = plot:FindFirstChild("DeliveryHitbox")
					break
				end
			end

			if base and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
				local humanoidRootPart = player.Character.HumanoidRootPart
				local humanoid = player.Character.Humanoid
				local plrPos = humanoidRootPart.Position

				local tppos = Vector3.new(base.Position.X, plrPos.Y, base.Position.Z)
				local distance = (tppos - plrPos).Magnitude
				local speed = humanoid.WalkSpeed
				local tweenTime = speed > 0 and (distance / speed) or 1

				local TweenService = game:GetService("TweenService")
				local tween = TweenService:Create(
					humanoidRootPart,
					TweenInfo.new(tweenTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
					{CFrame = CFrame.new(tppos) * (humanoidRootPart.CFrame - plrPos)}
				)
				tween:Play()
			end
		end
	end
})




local gui
local isGuiVisible = false

main.create_button({
	name = 'Instant Steal',
	flag = 'instantsteal',
	callback = function()
			local Players = game:GetService("Players")
			local ReplicatedStorage = game:GetService("ReplicatedStorage")
			local player = Players.LocalPlayer
			local buyRemote = ReplicatedStorage.Packages.Net["RF/CoinsShopService/RequestBuy"]

			local charConn = nil
			local speedBoostEnabled = false
			local isGuiVisible = false
			local gui = nil

			local function equipSpeedCoil()
				local backpack = player:FindFirstChild("Backpack")
				local char = player.Character
				if not (backpack and char) then return end
				local item = backpack:FindFirstChild("Speed Coil") or char:FindFirstChild("Speed Coil")
				if not item then
					pcall(function() buyRemote:InvokeServer("Speed Coil") end)
					item = backpack:WaitForChild("Speed Coil", 2)
				end
				if not item then return end
				item.Parent = char
			end

			local function unequipSpeedCoil()
				local char = player.Character
				if char then
					local item = char:FindFirstChild("Speed Coil")
					if item then
						item.Parent = player.Backpack
					end
				end
			end

			local function enableBypassSpeed()
				if charConn then charConn:Disconnect() end
				charConn = player.CharacterAdded:Connect(equipSpeedCoil)
				if player.Character then equipSpeedCoil() end
			end

			local function disableBypassSpeed()
				if charConn then charConn:Disconnect() end
				charConn = nil
				unequipSpeedCoil()
			end

			local Workspace = game:GetService("Workspace")
			local RunService = game:GetService("RunService")
			local TweenService = game:GetService("TweenService")
			local UserInputService = game:GetService("UserInputService")

			local Player = Players.LocalPlayer
			local Character = Player.Character or Player.CharacterAdded:Wait()
			local HRP = Character:WaitForChild("HumanoidRootPart")

			isGuiVisible = not isGuiVisible

			if isGuiVisible then
				if not gui then
					gui = Instance.new("ScreenGui")
					gui.Name = "TPGui"
					gui.Parent = Player:WaitForChild("PlayerGui")
					gui.ResetOnSpawn = false

					local frame = Instance.new("Frame", gui)
					frame.Size = UDim2.new(0, 200, 0, 150)
					frame.Position = UDim2.new(0.5, -100, 0.5, -75)
					frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
					frame.BorderSizePixel = 0

					Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 12)

					local gradient = Instance.new("UIGradient", frame)
					gradient.Color = ColorSequence.new{
						ColorSequenceKeypoint.new(0, Color3.fromRGB(200, 0, 0)),
						ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
					}
					gradient.Rotation = 45

					local titleLabel = Instance.new("TextLabel", frame)
					titleLabel.Size = UDim2.new(0.9, 0, 0, 30)
					titleLabel.Position = UDim2.new(0.05, 0, 0.05, 0)
					titleLabel.BackgroundTransparency = 1
					titleLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
					titleLabel.Font = Enum.Font.GothamBold
					titleLabel.TextSize = 16
					titleLabel.Text = "Instant Steal"

					local dragging = false
					local dragStart, startPos

					local function isWithinFrame(pos, frame)
						local framePos = frame.AbsolutePosition
						local frameSize = frame.AbsoluteSize
						return pos.X >= framePos.X and pos.X <= framePos.X + frameSize.X and
							   pos.Y >= framePos.Y and pos.Y <= framePos.Y + frameSize.Y
					end

					local function updatePosition(input)
						local delta = input.Position - dragStart
						frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
					end

					UserInputService.InputBegan:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							if input.Position and isWithinFrame(input.Position, frame) then
								dragging = true
								dragStart = input.Position
								startPos = frame.Position
							end
						end
					end)

					UserInputService.InputChanged:Connect(function(input)
						if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
							updatePosition(input)
						end
					end)

					UserInputService.InputEnded:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							dragging = false
						end
					end)

					local function makeButton(text, posY, callback)
						local btn = Instance.new("TextButton", frame)
						btn.Size = UDim2.new(0.8, 0, 0, 30)
						btn.Position = UDim2.new(0.1, 0, posY, 0)
						btn.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
						btn.TextColor3 = Color3.new(0, 0, 0)
						btn.Font = Enum.Font.GothamBold
						btn.TextSize = 14
						btn.Text = text
						btn.TextWrapped = true
						Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
						btn.MouseButton1Click:Connect(callback)
						return btn
					end

					local function getHRP()
						Character = Player.Character or Player.CharacterAdded:Wait()
						return Character:FindFirstChild("HumanoidRootPart")
					end

					local teleporting = false
					local function TP(cf)
						if teleporting then return end
						teleporting = true
						local hrp = getHRP()
						if hrp then
							hrp.CFrame = cf + Vector3.new(math.random(-1, 1) * 0.0001, 0, math.random(-1, 1) * 0.0001)
						end
						RunService.Heartbeat:Wait()
						teleporting = false
					end

					local function InstantSteal()
						local hrp = getHRP()
						if not hrp then return end

						local function findDelivery()
							for _, plot in ipairs(Workspace.Plots:GetDescendants()) do
								if plot.Name == "DeliveryHitbox" and plot.Parent:FindFirstChild("PlotSign") then
									local sign = plot.Parent.PlotSign
									if sign:FindFirstChild("YourBase") and sign.YourBase.Enabled then
										return plot
									end
								end
							end
						end

						local delivery = findDelivery()
						if not delivery then return end

						local target = delivery.CFrame * CFrame.new(0, -2, 0)
						local void = CFrame.new(0, -1e10, 0)

						for i = 1, 3 do
							TP(target)
							task.wait()
						end
						for i = 1, 2 do
							TP(void)
							task.wait(0.1)
							TP(target)
							task.wait(0.1)
						end
					end

					makeButton("STEAL", 0.35, InstantSteal)

					local speedButton = makeButton("ENABLE SPEED BOOST", 0.65, function()
						speedBoostEnabled = not speedBoostEnabled
						if speedBoostEnabled then
							enableBypassSpeed()
							speedButton.Text = "DISABLE SPEED BOOST"
						else
							disableBypassSpeed()
							speedButton.Text = "ENABLE SPEED BOOST"
						end
					end)

					Player.CharacterAdded:Connect(function(char)
						Character = char
						HRP = char:WaitForChild("HumanoidRootPart")
					end)
				else
					gui.Enabled = true
				end
			else
				if gui then
					gui.Enabled = false
				end
			end
	end
})



local noclip_enabled = false
local lastPosition = nil
local threshold = 10

main.create_toggle({
	name = 'Noclip',
	flag = 'noclip',
	section = 'left',
	enabled = false,
	callback = function(state)
		noclip_enabled = state
	end
})

game:GetService("RunService").Stepped:Connect(function()
	if noclip_enabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		local char = player.Character
		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end

		local hrp = char:FindFirstChild("HumanoidRootPart")
		if hrp then
			local currentPos = hrp.Position
			if lastPosition then
				local distance = (currentPos - lastPosition).Magnitude
				if distance > threshold then
					hrp.CFrame = CFrame.new(lastPosition)
				else
					lastPosition = currentPos
				end
			else
				lastPosition = currentPos
			end
		end
	end
end)


local player = game:GetService("Players").LocalPlayer  
local RunService = game:GetService("RunService")  
local UserInputService = game:GetService("UserInputService")

local boostConnection = nil  
local char = player.Character or player.CharacterAdded:Wait()  
local root = char:WaitForChild("HumanoidRootPart")  
local humanoid = char:WaitForChild("Humanoid")  
  
local function enableJumpBoost()  
    char = player.Character or player.CharacterAdded:Wait()  
    root = char:WaitForChild("HumanoidRootPart")  
    humanoid = char:WaitForChild("Humanoid")  

    player.CharacterAdded:Connect(function(newChar)  
        char = newChar  
        root = char:WaitForChild("HumanoidRootPart")  
        humanoid = char:WaitForChild("Humanoid")  
    end)  

    boostConnection = RunService.Stepped:Connect(function()  
        if not char or not humanoid or not root then return end  

        if humanoid:GetState() == Enum.HumanoidStateType.Freefall then  
            root.Velocity = Vector3.new(  
                root.Velocity.X,  
                math.clamp(root.Velocity.Y, -20, 150),  
                root.Velocity.Z  
            )  
        end  
    end)  

    UserInputService.JumpRequest:Connect(function()  
        if humanoid and root then  
            root.AssemblyLinearVelocity = Vector3.new(0, 100, 0)  
        end  
    end)  
end  

  
local function disableJumpBoost()  
    if boostConnection then  
        boostConnection:Disconnect()  
        boostConnection = nil  
    end  
end  


main.create_toggle({
	name = 'Smooth Jump',
	flag = 'smoothjump',
	section = 'right',
	enabled = false,
	callback = function(state)
		if state then
			enableJumpBoost()
		else
			disableJumpBoost()
		end
	end
})


local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local Players = game:GetService("Players")

local Player = Players.LocalPlayer
local Connections = {}
local AirJumpEnabled = false

-- Setup Jump Logic
Connections.JumpButton = nil

local function enableSmoothJump()
    if Connections.JumpButton then return end

    Connections.JumpButton = UserInputService.JumpRequest:Connect(function()
        if not AirJumpEnabled then return end

        local character = Player.Character
        if not character then return end

        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")

        if humanoid and rootPart and humanoid.FloorMaterial == Enum.Material.Air then
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
            bodyVelocity.Velocity = Vector3.new(0, 65, 0)
            bodyVelocity.Parent = rootPart
            Debris:AddItem(bodyVelocity, 0.3)
        end
    end)
end

local function disableSmoothJump()
    if Connections.JumpButton then
        Connections.JumpButton:Disconnect()
        Connections.JumpButton = nil
    end
end


main.create_toggle({
	name = 'Smooth Jump v2',
	flag = 'smoothjumpv2',
	section = 'left',
	enabled = false,
	callback = function(state)
		AirJumpEnabled = state
		if state then
			enableSmoothJump()
		else
			disableSmoothJump()
		end
	end
})


local infJumpConnection = nil
local infJumpEnabled = false
local UserInputService = game:GetService("UserInputService")
local player = game:GetService("Players").LocalPlayer

main.create_toggle({
	name = 'Inf Jump',
	flag = 'infjump',
	section = 'right',
	enabled = false,
	callback = function(state)
		infJumpEnabled = state

		if infJumpConnection then
			infJumpConnection:Disconnect()
			infJumpConnection = nil
		end

		if state then
			infJumpConnection = UserInputService.JumpRequest:Connect(function()
				local character = player.Character or player.CharacterAdded:Wait()
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end)
		end
	end
})


-- Reconnect on respawn if toggle is still active
player.CharacterAdded:Connect(function()
    if infJumpEnabled then
        task.wait(1)
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and infJumpConnection == nil then
            infJumpConnection = UserInputService.JumpRequest:Connect(function()
                if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end)
        end
    end
end)



local Players = game:GetService("Players")
local player = Players.LocalPlayer
local floatForce = Vector3.new(0, 40, 0)
local bodyVelocity = nil

main.create_toggle({
	name = 'Fly',
	flag = 'fly',
	section = 'right',
	enabled = false,
	callback = function(enabled)
		local character = player.Character or player.CharacterAdded:Wait()
		local root = character:WaitForChild("HumanoidRootPart")

		if enabled then
			bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.Name = "FloatForce"
			bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
			bodyVelocity.Velocity = floatForce
			bodyVelocity.Parent = root

			character:WaitForChild("Humanoid").Died:Connect(function()
				if bodyVelocity then
					bodyVelocity:Destroy()
					bodyVelocity = nil
				end
			end)
		else
			if bodyVelocity then
				bodyVelocity:Destroy()
				bodyVelocity = nil
			end
		end
	end
})


-- === ESP SYSTEM ===
local espEnabled = false
local espInstances = {}

local function createESP(player)
    if not espEnabled then return end
    if player == Players.LocalPlayer then return end

    local character = player.Character
    if not character then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 10)
    if not humanoidRootPart then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_" .. player.Name
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 200, 0, 30)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.Adornee = humanoidRootPart
    billboard.Parent = humanoidRootPart

    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "NameLabel"
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = player.DisplayName
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    textLabel.TextStrokeTransparency = 0
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Parent = billboard

    espInstances[player] = billboard

    local function onCharacterAdded(newCharacter)
        if billboard then billboard:Destroy() end
        local newHRP = newCharacter:WaitForChild("HumanoidRootPart", 10)
        if newHRP and espEnabled then
            billboard.Adornee = newHRP
            billboard.Parent = newHRP
        end
    end
    player.CharacterAdded:Connect(onCharacterAdded)
end

local function removeESP(player)
    local espInstance = espInstances[player]
    if espInstance then
        espInstance:Destroy()
        espInstances[player] = nil
    end
end

local function toggleESP(enable)
    espEnabled = enable
    if enable then
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= player then
                coroutine.wrap(function()
                    createESP(p)
                end)()
            end
        end
    else
        for _, espInstance in pairs(espInstances) do
            if espInstance then
                espInstance:Destroy()
            end
        end
        espInstances = {}
    end
end

local function initPlayerConnections()
    Players.PlayerAdded:Connect(function(p)
        p.CharacterAdded:Connect(function(character)
            if p ~= player and espEnabled then
                task.wait(1)
                createESP(p)
            end
        end)
    end)
    Players.PlayerRemoving:Connect(removeESP)
end
initPlayerConnections()

-- === RARITY & MUTATION ESP SETTINGS ===
local RaritySettings = {
    ["Legendary"] = { Color = Color3.fromRGB(255, 215, 0), Size = UDim2.new(0, 150, 0, 50) },
    ["Mythic"] = { Color = Color3.fromRGB(138, 43, 226), Size = UDim2.new(0, 150, 0, 60) },
    ["Brainrot God"] = { Color = Color3.fromRGB(255, 0, 0), Size = UDim2.new(0, 180, 0, 60) },
    ["Secret"] = { Color = Color3.fromRGB(255, 20, 147), Size = UDim2.new(0, 200, 0, 70) }
}

local MutationSettings = {
    ["Gold"] = { Color = Color3.fromRGB(255, 215, 0), Size = UDim2.new(0, 120, 0, 30) },
    ["Diamond"] = { Color = Color3.fromRGB(185, 242, 255), Size = UDim2.new(0, 120, 0, 30) },
    ["Rainbow"] = { Color = Color3.fromRGB(255, 0, 255), Size = UDim2.new(0, 120, 0, 30) },
    ["Bloodrot"] = { Color = Color3.fromRGB(139, 0, 0), Size = UDim2.new(0, 120, 0, 30) }
}

local activeESP = {}
local activeLockTimeEsp = false
local lteInstances = {}

local myPlotName
for _, plot in ipairs(workspace.Plots:GetChildren()) do
    if plot:FindFirstChild("YourBase", true) and plot:FindFirstChild("YourBase", true).Enabled then
        myPlotName = plot.Name
        break
    end
end

local function getOwner(plot)
    local text = plot:FindFirstChild("PlotSign") and
        plot.PlotSign:FindFirstChild("SurfaceGui") and
        plot.PlotSign.SurfaceGui.Frame.TextLabel.Text or "Unknown"
    return text:match("^(.-)'s Base") or text
end

local function updatelock()
    if not activeLockTimeEsp then
        for _, instance in pairs(lteInstances) do
            if instance then
                instance:Destroy()
            end
        end
        lteInstances = {}
        return
    end

    for _, plot in pairs(workspace.Plots:GetChildren()) do
        local timeLabel = plot:FindFirstChild("Purchases", true) and
            plot.Purchases:FindFirstChild("PlotBlock", true) and
            plot.Purchases.PlotBlock.Main:FindFirstChild("BillboardGui", true) and
            plot.Purchases.PlotBlock.Main.BillboardGui:FindFirstChild("RemainingTime", true)

        if timeLabel and timeLabel:IsA("TextLabel") then
            local espName = "LockTimeESP_" .. plot.Name
            local existingBillboard = plot:FindFirstChild(espName)

            local isUnlocked = timeLabel.Text == "0s"
            local displayText = isUnlocked and "Unlocked" or ("Lock: " .. timeLabel.Text)

            local textColor = isUnlocked and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)

            if not existingBillboard then
                local billboard = Instance.new("BillboardGui")
                billboard.Name = espName
                billboard.Size = UDim2.new(0, 200, 0, 30)
                billboard.StudsOffset = Vector3.new(0, 5, 0)
                billboard.AlwaysOnTop = true
                billboard.Adornee = plot.Purchases.PlotBlock.Main

                local label = Instance.new("TextLabel")
                label.Text = displayText
                label.Size = UDim2.new(1, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.TextScaled = true
                label.TextColor3 = textColor
                label.TextStrokeColor3 = Color3.new(0, 0, 0)
                label.TextStrokeTransparency = 0
                label.Font = Enum.Font.SourceSansBold
                label.Parent = billboard

                billboard.Parent = plot
                lteInstances[plot.Name] = billboard
            else
                existingBillboard.TextLabel.Text = displayText
                existingBillboard.TextLabel.TextColor3 = textColor
            end
        end
    end
end

local function updateRESP()
    for _, plot in pairs(workspace.Plots:GetChildren()) do
        if plot.Name ~= myPlotName then
            for _, child in pairs(plot:GetDescendants()) do
                if child.Name == "Rarity" and child:IsA("TextLabel") and RaritySettings[child.Text] then
                    local parentModel = child.Parent.Parent
                    local espName = child.Text .. "_ESP"
                    local mutationEspName = "Mutation_ESP"
                    local existingBillboard = parentModel:FindFirstChild(espName)
                    local existingMutationBillboard = parentModel:FindFirstChild(mutationEspName)

                    if activeESP[child.Text] then
                        if not existingBillboard then
                            local settings = RaritySettings[child.Text]

                            local billboard = Instance.new("BillboardGui")
                            billboard.Name = espName
                            billboard.Size = settings.Size
                            billboard.StudsOffset = Vector3.new(0, 3, 0)
                            billboard.AlwaysOnTop = true
                            billboard.Adornee = parentModel

                            local label = Instance.new("TextLabel")
                            label.Text = child.Parent.DisplayName.Text
                            label.Size = UDim2.new(1, 0, 1, 0)
                            label.BackgroundTransparency = 1
                            label.TextScaled = true
                            label.TextColor3 = settings.Color
                            label.TextStrokeColor3 = Color3.new(0, 0, 0)
                            label.TextStrokeTransparency = 0
                            label.Font = Enum.Font.SourceSansBold
                            label.Parent = billboard

                            billboard.Parent = parentModel
                        end

                        local mutation = child.Parent:FindFirstChild("Mutation")
                        if mutation and mutation:IsA("TextLabel") and MutationSettings[mutation.Text] then
                            local mutationSettings = MutationSettings[mutation.Text]

                            if not existingMutationBillboard then
                                local mutationBillboard = Instance.new("BillboardGui")
                                mutationBillboard.Name = mutationEspName
                                mutationBillboard.Size = mutationSettings.Size
                                mutationBillboard.StudsOffset = Vector3.new(0, 6, 0)
                                mutationBillboard.AlwaysOnTop = true
                                mutationBillboard.Adornee = parentModel

                                local mutationLabel = Instance.new("TextLabel")
                                mutationLabel.Text = mutation.Text
                                mutationLabel.Size = UDim2.new(1, 0, 1, 0)
                                mutationLabel.BackgroundTransparency = 1
                                mutationLabel.TextScaled = true
                                mutationLabel.TextColor3 = mutationSettings.Color
                                mutationLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
                                mutationLabel.TextStrokeTransparency = 0
                                mutationLabel.Font = Enum.Font.SourceSansBold
                                mutationLabel.Parent = mutationBillboard

                                mutationBillboard.Parent = parentModel
                            else
                                existingMutationBillboard.TextLabel.Text = mutation.Text
                                existingMutationBillboard.TextLabel.TextColor3 = mutationSettings.Color
                            end
                        elseif existingMutationBillboard then
                            existingMutationBillboard:Destroy()
                        end
                    else
                        if existingBillboard then existingBillboard:Destroy() end
                        if existingMutationBillboard then existingMutationBillboard:Destroy() end
                    end
                end
            end
        end
    end
end

-- === PET FINDER DROPDOWN ===
local petModels = ReplicatedStorage.Models.Animals:GetChildren()

local petNames = {}
for _, pet in ipairs(petModels) do
    table.insert(petNames, pet.Name)
end

local sel = nil
local run = false

esp.create_dropdown({
	name = 'Find Pets',
	flag = 'findpets',
	section = 'left',
	option = petNames[1],
	options = petNames,
	callback = function(val)
		sel = val
		if run then return end
		run = true

		task.spawn(function()
			while sel do
				local txt = "No selected pet found"
				for _, p in pairs(workspace.Plots:GetChildren()) do
					if p.Name ~= myPlotName then
						local own = getOwner(p)
						for _, v in pairs(p:GetDescendants()) do
							if v.Name == "DisplayName" and v.Text == sel then
								txt = sel.." | Owner: "..own
							end
						end
					end
				end
                warn(txt)
				task.wait(.5)
			end
			run = false
		end)
	end
})

-- === ESP TYPES MULTIDROPDOWN ===
esp.create_dropdown({
   name = 'ESP',
   flag = 'ESPTypesDropdown',
   section = 'left',
   option = 'Lock',
   options = {'Lock', 'Players', 'Legendary', 'Mythic', 'Brainrot God', 'Secret'},
   callback = function(value: string)
   	if value == "Players" then
   		toggleESP(true)
   	else
   		toggleESP(false)
   	end
   	
   	activeESP["Legendary"] = (value == "Legendary")
   	activeESP["Mythic"] = (value == "Mythic")
   	activeESP["Brainrot God"] = (value == "Brainrot God")
   	activeESP["Secret"] = (value == "Secret")
   	activeLockTimeEsp = (value == "Lock")
   	
   	updatelock()
   	updateRESP()
   end
})

task.spawn(function()
   while true do
   	task.wait(0.25)
   	if activeLockTimeEsp then updatelock() end
   	if next(activeESP) ~= nil then updateRESP() end
   end
end)



local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local plotTimers_Enabled = false
local plotTimers_Coroutine = nil
local plotTimers_RenderConnections = {}
local plotTimers_OriginalProperties = {}

-- Disable logic
local function disablePlotTimers()
    plotTimers_Enabled = false
    if plotTimers_Coroutine then
        task.cancel(plotTimers_Coroutine)
        plotTimers_Coroutine = nil
    end
    for _, conn in pairs(plotTimers_RenderConnections) do
        pcall(function() conn:Disconnect() end)
    end
    table.clear(plotTimers_RenderConnections)
    for label, props in pairs(plotTimers_OriginalProperties) do
        pcall(function()
            if label and label.Parent then
                local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
                if bb and bb.Parent then
                    bb.Enabled = props.bb_enabled
                    bb.AlwaysOnTop = props.bb_alwaysOnTop
                    bb.Size = props.bb_size
                    bb.MaxDistance = props.bb_maxDistance
                    label.TextScaled = props.label_textScaled
                    label.TextWrapped = props.label_textWrapped
                    label.AutomaticSize = props.label_automaticSize
                    label.Size = props.label_size
                    label.TextSize = props.label_textSize
                end
            end
        end)
    end
    table.clear(plotTimers_OriginalProperties)
end

-- Enable logic
local function enablePlotTimers()
    disablePlotTimers()
    plotTimers_Enabled = true
    plotTimers_Coroutine = task.spawn(function()
        local camera = Workspace.CurrentCamera
        local DISTANCE_THRESHOLD = 45
        local SCALE_START, SCALE_RANGE = 100, 300
        local MIN_TEXT_SIZE, MAX_TEXT_SIZE = 30, 36

        while plotTimers_Enabled do
            pcall(function()
                for _, label in ipairs(Workspace.Plots:GetDescendants()) do
                    if label:IsA("TextLabel") and label.Name == "RemainingTime" then
                        if plotTimers_RenderConnections[label] then continue end
                        local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
                        if not bb then continue end
                        local model = bb:FindFirstAncestorWhichIsA("Model")
                        if not model then continue end
                        local basePart = model:FindFirstChildWhichIsA("BasePart", true)
                        if not basePart then continue end

                        if not plotTimers_OriginalProperties[label] then
                            plotTimers_OriginalProperties[label] = {
                                bb_enabled = bb.Enabled,
                                bb_alwaysOnTop = bb.AlwaysOnTop,
                                bb_size = bb.Size,
                                bb_maxDistance = bb.MaxDistance,
                                label_textScaled = label.TextScaled,
                                label_textWrapped = label.TextWrapped,
                                label_automaticSize = label.AutomaticSize,
                                label_size = label.Size,
                                label_textSize = label.TextSize,
                            }
                        end

                        bb.MaxDistance = 10000
                        bb.AlwaysOnTop = true
                        bb.ClipsDescendants = false
                        bb.Size = UDim2.new(0, 300, 0, 150)
                        label.TextScaled = false
                        label.TextWrapped = true
                        label.ClipsDescendants = false
                        label.Size = UDim2.new(1, 0, 0, 32)
                        label.AutomaticSize = Enum.AutomaticSize.Y

                        local conn = RunService.RenderStepped:Connect(function()
                            if not basePart or not basePart.Parent or not bb or not bb.Parent then
                                if plotTimers_RenderConnections[label] then
                                    plotTimers_RenderConnections[label]:Disconnect()
                                    plotTimers_RenderConnections[label] = nil
                                end
                                return
                            end
                            local distance = (camera.CFrame.Position - basePart.Position).Magnitude
                            if distance > DISTANCE_THRESHOLD and basePart.Position.Y >= 0 then
                                bb.Enabled = false
                                return
                            end
                            bb.Enabled = true
                            local t = math.clamp((distance - SCALE_START) / SCALE_RANGE, 0, 1)
                            local newTextSize = math.clamp(MIN_TEXT_SIZE + (MAX_TEXT_SIZE - MIN_TEXT_SIZE) * t, MIN_TEXT_SIZE, MAX_TEXT_SIZE)
                            label.TextSize = newTextSize
                            label.Size = UDim2.new(1, 0, 0, newTextSize + 6)
                        end)

                        plotTimers_RenderConnections[label] = conn
                    end
                end
            end)
            task.wait(1)
        end
    end)
end

-- GUI Toggle
esp.create_toggle({
	name = 'Esp lock timer base',
	flag = 'baselocktimer',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			enablePlotTimers()
		else
			disablePlotTimers()
		end
	end
})


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer


local AnimalsModule = require(ReplicatedStorage.Datas.Animals)
local TraitsModule = require(ReplicatedStorage.Datas.Traits)
local MutationsModule = require(ReplicatedStorage.Datas.Mutations)
local PlotController = require(ReplicatedStorage.Controllers:WaitForChild("PlotController"))


local espEnabled = false
local isPetScanRunning = false
local highestGenAnimal = nil
local INTERVAL = 0.25

-- All valid pet names
local ALL_ANIMAL_NAMES = {}
for k, _ in pairs(AnimalsModule) do
    ALL_ANIMAL_NAMES[k] = true
end

local function formatNumber(n)
    return tostring(n):reverse():gsub('%d%d%d', '%1,'):reverse():gsub('^,', '')
end

local function isBasePet(m)
    return m:IsA("Model") and ALL_ANIMAL_NAMES[m.Name]
end

local function getMyPlot()
    local ok, result = pcall(function()
        return PlotController:GetMyPlot()
    end)
    return ok and result and result.PlotModel or nil
end

local function isInEnemyPlot(model)
    local myPlot = getMyPlot()
    return not (myPlot and myPlot:IsAncestorOf(model))
end

local function getTraitMultiplier(model)
    local traitJson = (model:FindFirstChild("Instance") or model):GetAttribute("Traits")
    if not traitJson then return 1 end

    local success, traitList = pcall(function()
        return HttpService:JSONDecode(traitJson)
    end)
    if not success or typeof(traitList) ~= "table" then return 1 end

    local mult = 1
    for _, traitName in ipairs(traitList) do
        local trait = TraitsModule[traitName]
        if trait and trait.MultiplierModifier then
            mult *= trait.MultiplierModifier
        end
    end
    return mult
end

local function getMutationMultiplier(model)
    local mutation = model:GetAttribute("Mutation")
    local data = mutation and MutationsModule[mutation]
    return (data and data.MultiplierModifier) or 1
end

local function getFinalGeneration(model)
    local animalData = AnimalsModule[model.Name]
    if not animalData then return 0 end

    local baseGen = animalData.Generation or 0
    local traitMult = getTraitMultiplier(model)
    local mutationMult = getMutationMultiplier(model)
    return math.round(baseGen * traitMult * mutationMult)
end


local function startRainbow(obj, prop)
    local cycleTime = 4
    task.spawn(function()
        while obj and obj.Parent do
            local h = (tick() % cycleTime) / cycleTime
            obj[prop] = Color3.fromHSV(h, 1, 1)
            RunService.Heartbeat:Wait()
        end
    end)
end

local function clearPetESP()
    for _, m in ipairs(workspace:GetChildren()) do
        if m:FindFirstChild("PetESP") then m.PetESP:Destroy() end
        if m:FindFirstChild("PetESP_Label") then m.PetESP_Label:Destroy() end
    end
end

local function attachPetESP(m, g)
    local root = m:FindFirstChild("RootPart") or m:FindFirstChildWhichIsA("BasePart")
    if not root then return end

    local hl = Instance.new('Highlight')
    hl.Name = "PetESP"
    hl.Adornee = m
    hl.OutlineColor = Color3.new(0, 0, 0)
    hl.FillTransparency = 0.25
    hl.OutlineTransparency = 0
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Parent = m
    startRainbow(hl, "FillColor")
    startRainbow(hl, "OutlineColor")

    local gui = Instance.new('BillboardGui')
    gui.Name = "PetESP_Label"
    gui.Adornee = root
    gui.AlwaysOnTop = true
    gui.Size = UDim2.new(0, 400, 0, 80)
    gui.StudsOffset = Vector3.new(0, 6.5, 0)
    gui.Parent = m

    local nameLabel = Instance.new('TextLabel')
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0.5, 0, 0.35, 0)
    nameLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Font = Enum.Font.GothamBlack
    nameLabel.TextSize = 22
    nameLabel.Text = m.Name:upper()
    nameLabel.TextXAlignment = Enum.TextXAlignment.Center
    nameLabel.Parent = gui
    startRainbow(nameLabel, "TextColor3")

    local gL = Instance.new('TextLabel')
    gL.Size = UDim2.new(1, 0, 0.5, 0)
    gL.Position = UDim2.new(0.5, 0, 0.75, 0)
    gL.AnchorPoint = Vector2.new(0.5, 0.5)
    gL.BackgroundTransparency = 1
    gL.Font = Enum.Font.GothamBlack
    gL.TextSize = 32
    gL.Text = '$' .. formatNumber(g) .. '/s'
    gL.TextXAlignment = Enum.TextXAlignment.Center
    gL.Parent = gui
    startRainbow(gL, "TextColor3")
end


local function runPetScanLoop()
    if isPetScanRunning then return end
    isPetScanRunning = true

    while espEnabled do
        local highest, bestGen = nil, -1
        for _, m in ipairs(workspace:GetChildren()) do
            if isBasePet(m) and isInEnemyPlot(m) then
                local g = getFinalGeneration(m)
                if g > bestGen then
                    bestGen = g
                    highest = m
                end
            end
        end

        highestGenAnimal = highest
        clearPetESP()
        if highest then
            attachPetESP(highest, bestGen)
        end

        task.wait(INTERVAL)
    end

    -- Cleanup on stop
    clearPetESP()
    highestGenAnimal = nil
    isPetScanRunning = false
end


function enableHighestGenESP()
    espEnabled = true
    task.spawn(runPetScanLoop)
end

function disableHighestGenESP()
    espEnabled = false
end


enableHighestGenESP()



esp.create_toggle({
	name = 'Esp best brainrot',
	flag = 'espbestbrainrot',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			enableHighestGenESP()
		else
			disableHighestGenESP()
		end
	end
})



-- === TELEPORT TAB ===-- === TELEPORT TAB ===
-- SELECT POSITION + LOOP GOTO SETUP

teleport.create_toggle({
	name = 'Teleport to Sky',
	flag = 'teleporttosky',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			local character = player.Character
			if character then
				local root = character:FindFirstChild("HumanoidRootPart")
				if root then
					root.CFrame = root.CFrame + Vector3.new(0, 150, 0)
				end
			end
		end
	end
})

teleport.create_toggle({
	name = 'Teleport to Ground',
	flag = 'teleporttoground',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			local character = player.Character
			if character then
				local root = character:FindFirstChild("HumanoidRootPart")
				if root then
					root.CFrame = root.CFrame - Vector3.new(0, 189, 0)
				end
			end
		end
	end
})


local player = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

getgenv().posgoto = getgenv().posgoto or nil
getgenv().clickToSet = false
getgenv().loopGoto = false

-- Create red marker
local marker = Instance.new("Part")
marker.Anchored = true
marker.CanCollide = false
marker.Size = Vector3.new(4, 0.2, 4)
marker.Material = Enum.Material.Neon
marker.Color = Color3.fromRGB(255, 0, 0)
marker.Transparency = 1
marker.Name = "GotoMarker"
marker.Parent = workspace

-- Set position logic
local function setTargetPosition(worldPos)
    local finalPos = worldPos + Vector3.new(0, 1.5, 0)
    marker.CFrame = CFrame.new(finalPos)
    marker.Transparency = 0
    getgenv().posgoto = CFrame.new(finalPos)
end

-- Raycast from screen
local function castRay(screenPosition)
    local unitRay = Camera:ViewportPointToRay(screenPosition.X, screenPosition.Y)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {player.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = workspace:Raycast(unitRay.Origin, unitRay.Direction * 500, rayParams)
    if result then
        setTargetPosition(result.Position)
    end
end

-- Desktop click
if UserInputService.MouseEnabled then
    local mouse = player:GetMouse()
    mouse.Button1Down:Connect(function()
        if getgenv().clickToSet then
            local mousePos = UserInputService:GetMouseLocation()
            castRay(Vector2.new(mousePos.X, mousePos.Y - 36)) -- Adjust for top bar
        end
    end)
end

-- Mobile tap
UserInputService.TouchTap:Connect(function(tapPositions)
    if getgenv().clickToSet and #tapPositions > 0 then
        castRay(tapPositions[1])
    end
end)

-- Select Position Toggle
teleport.create_toggle({
	name = 'Select Position',
	flag = 'selectposition',
	section = 'right',
	enabled = false,
	callback = function(state)
		getgenv().clickToSet = state
		if not state and getgenv().posgoto then
			print("Saved")
		end
	end
})


-- Loop Goto Toggle (with pre-jump to sky)
teleport.create_toggle({
	name = 'Loop Goto',
	flag = 'loopgoto',
	section = 'right',
	enabled = false,
	callback = function(state)
		getgenv().loopGoto = state

		if state then
			coroutine.wrap(function()
				while getgenv().loopGoto do
					local pos = getgenv().posgoto
					local char = player.Character
					local root = char and char:FindFirstChild("HumanoidRootPart")

					if pos and root then
						local voidPos = CFrame.new(0, -500, 0)
						local startT = os.clock()
						while os.clock() - startT < 1 do
							if not getgenv().loopGoto then break end
							root.CFrame = voidPos
							task.wait()
						end

						local jumpTo = pos
						local secondT = os.clock()
						while os.clock() - secondT < 1 do
							if not getgenv().loopGoto then break end
							root.CFrame = jumpTo
							task.wait()
						end
					end

					task.wait(0.1)
				end
			end)()
		end
	end
})


-- === UTILITY TAB ===

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Player = Players.LocalPlayer
local KillAuraActive = false
local KillAuraConnection = nil

-- Start Kill Aura
local function startKillAura()
    if KillAuraActive then return end
    KillAuraActive = true

    KillAuraConnection = RunService.Heartbeat:Connect(function()
        pcall(function()
            local char = Player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then return end

            local tool = Player.Backpack:FindFirstChildOfClass("Tool")
            if not tool then tool = char:FindFirstChildOfClass("Tool") end
            if not tool then return end

            local nearbyPlayers = {}
            for _, other in pairs(Players:GetPlayers()) do
                if other ~= Player and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (other.Character.HumanoidRootPart.Position - char.HumanoidRootPart.Position).Magnitude
                    if dist < 20 then
                        table.insert(nearbyPlayers, {player = other, distance = dist})
                    end
                end
            end

            table.sort(nearbyPlayers, function(a, b) return a.distance < b.distance end)

            for i = 1, math.min(#nearbyPlayers, 3) do
                local targetChar = nearbyPlayers[i].player.Character
                if targetChar and targetChar:FindFirstChild("HumanoidRootPart") then
                    local dir = (targetChar.HumanoidRootPart.Position - char.HumanoidRootPart.Position).Unit
                    local lookDir = Vector3.new(dir.X, 0, dir.Z)
                    char.HumanoidRootPart.CFrame = CFrame.lookAt(char.HumanoidRootPart.Position, char.HumanoidRootPart.Position + lookDir)

                    if tool.Parent == Player.Backpack then
                        char.Humanoid:EquipTool(tool)
                    end
                    if tool:FindFirstChild("Handle") then
                        tool:Activate()
                    end
                    task.wait(0.05)
                end
            end
        end)
    end)
end

-- Stop Kill Aura
local function stopKillAura()
    if KillAuraConnection then
        KillAuraConnection:Disconnect()
        KillAuraConnection = nil
    end
    KillAuraActive = false
end

-- Add toggle to the Utility tab
utility.create_toggle({
	name = 'Kill Aura',
	flag = 'killaura',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			startKillAura()
		else
			stopKillAura()
		end
	end
})


utility.create_toggle({
	name = 'Anti Teleport',
	flag = 'antiteleport',
	section = 'left',
	enabled = false,
	callback = function(state)
		antiteleport = state
	end
})

local player = game:GetService("Players").LocalPlayer
local tableofconnections = {}
local antiragdoll = false

local function protectTool(tool)
    if tool:IsA("BasePart") then
        -- Prevent anchoring
        table.insert(tableofconnections, tool:GetPropertyChangedSignal("Anchored"):Connect(function()
            if tool.Anchored and antiragdoll then
                tool.Anchored = false
            end
        end))
        -- Remove ragdoll constraints
        table.insert(tableofconnections, tool.ChildAdded:Connect(function(c)
            if c and (c:IsA("BallSocketConstraint") or c:IsA("HingeConstraint") or c.Name == "Attachment") then
                c:Destroy()
                local char = player.Character
                if char and char:FindFirstChildOfClass("Humanoid") then
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    hum:ChangeState(Enum.HumanoidStateType.GettingUp)
                    hum.PlatformStand = false
                    workspace.CurrentCamera.CameraSubject = hum
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then hrp.CanCollide = true end
                end
            end
        end))
    elseif tool:IsA("Humanoid") then
        table.insert(tableofconnections, tool.StateChanged:Connect(function(_, newState)
            if antiragdoll and (newState == Enum.HumanoidStateType.Physics or newState == Enum.HumanoidStateType.Ragdoll) then
                tool:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        end))
    end
end

local function setupChar(character)
    for _, v in pairs(character:GetChildren()) do
        protectTool(v)
    end
    character.ChildAdded:Connect(protectTool)
end

-- Toggle in Utility tab
utility.create_toggle({
	name = 'Anti Ragdoll',
	flag = 'antiragdoll',
	section = 'right',
	enabled = false,
	callback = function(state)
		antiragdoll = state
		for _, conn in pairs(tableofconnections) do
			pcall(function() conn:Disconnect() end)
		end
		table.clear(tableofconnections)
		if state and player.Character then
			setupChar(player.Character)
		end
	end
})

player.CharacterAdded:Connect(function(char)
    if antiragdoll then
        setupChar(char)
    end
end)


local aimbotConnection = nil
local aimbotRange = 100

local function getClosestTarget()
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local closest, minDist = nil, aimbotRange
    for _, p in ipairs(game.Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChildOfClass("Humanoid") then
            if p.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
                local dist = (root.Position - p.Character.HumanoidRootPart.Position).Magnitude
                if dist < minDist then
                    closest = p
                    minDist = dist
                end
            end
        end
    end
    return closest
end

utility.create_toggle({
	name = 'Aimbot',
	flag = 'aimbot',
	section = 'left',
	enabled = false,
	callback = function(st)
		if st then
			aim = RunService.Heartbeat:Connect(function()
				local tgt = getClosestTarget()
				local rt = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
				if tgt and rt and tgt.Character and tgt.Character:FindFirstChild("HumanoidRootPart") then
					local pos = tgt.Character.HumanoidRootPart.Position
					rt.CFrame = CFrame.lookAt(rt.Position, Vector3.new(pos.X, rt.Position.Y, pos.Z))
				end
			end)
		else
			if aim then
				aim:Disconnect()
				aim = nil
			end
		end
	end
})







utility.create_toggle({
	name = 'Anti Sentry',
	flag = 'antisentry',
	section = 'right',
	enabled = false,
	callback = function(state)
		if state then
			if AntiSentryConnection then AntiSentryConnection:Disconnect() end

			local Players = game:GetService("Players")
			local RunService = game:GetService("RunService")
			local LocalPlayer = Players.LocalPlayer

			local function getCharacter()
				return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
			end

			local function getHumanoidRootPart()
				return getCharacter():WaitForChild("HumanoidRootPart", 3)
			end

			AntiSentryConnection = RunService.Heartbeat:Connect(function()
				local hrp = getHumanoidRootPart()
				if not hrp then return end

				for _, obj in pairs(workspace:GetChildren()) do
					if obj:IsA("Model") and obj.Name:lower():find("sentry") and obj:FindFirstChild("HumanoidRootPart") then
						local sentryHRP = obj.HumanoidRootPart
						local distance = (sentryHRP.Position - hrp.Position).Magnitude

						if distance <= 70 then
							pcall(function()
								sentryHRP.Anchored = false
								sentryHRP.CanCollide = false
								sentryHRP.Massless = true
								sentryHRP.CFrame = hrp.CFrame + Vector3.new(0, 0, -3)
							end)
						end
					end
				end
			end)
		else
			if AntiSentryConnection then
				AntiSentryConnection:Disconnect()
				AntiSentryConnection = nil
			end
		end
	end
})



local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

--  Runtime flags and memory
local antiTrapEnabled = false
local processedTraps = {}

--  Anti Trap logic loop
RunService.Heartbeat:Connect(function()
    if not antiTrapEnabled then return end

    for _, v in ipairs(Workspace:GetDescendants()) do
        if processedTraps[v] then continue end

        if v:IsA("BasePart") and v.Name:lower():find("trap") then
            pcall(function()
                local safe = Instance.new("Part")
                safe.Size = v.Size
                safe.CFrame = v.CFrame
                safe.Anchored = true
                safe.CanCollide = true
                safe.Color = Color3.fromRGB(60, 255, 60)
                safe.Name = "FakeTrap"
                safe.Transparency = 0.3
                safe.Material = Enum.Material.Neon
                safe.Parent = Workspace

                processedTraps[safe] = true
                processedTraps[v] = true
                v:Destroy()
            end)
        elseif v:IsA("Model") and v.Name:lower():find("trap") then
            pcall(function()
                processedTraps[v] = true
                v:Destroy()
            end)
        end
    end
end)

--  Fluent UI Toggle Button under Utility tab
utility.create_toggle({
	name = 'Anti Trap',
	flag = 'antitrap',
	section = 'right',
	enabled = false,
	callback = function(state)
		antiTrapEnabled = state
	end
})


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Flag for enabling
local antiInvisEnabled = false

-- Loop to reveal invisible players
RunService.Heartbeat:Connect(function()
    if not antiInvisEnabled then return end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= Players.LocalPlayer and plr.Character then
            for _, part in ipairs(plr.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    pcall(function()
                        part.Transparency = 0
                        part.Color = Color3.fromRGB(255, 60, 60)
                    end)
                end
            end
        end
    end
end)

-- Fluent UI Toggle under Utility tab
utility.create_toggle({
	name = 'Anti Invisibility',
	flag = 'antiinvis',
	section = 'right',
	enabled = false,
	callback = function(state)
		antiInvisEnabled = state
	end
})



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

-- Toggle flag
local bringShopEnabled = false

-- Helper to get local player's HRP
local function getHRP()
    return lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
end

-- Shop bring loop
RunService.Heartbeat:Connect(function()
    if not bringShopEnabled then return end

    local hrp = getHRP()
    if not hrp then return end

    local shop = workspace:FindFirstChild("ShopNPCCash")
    if shop and shop:IsA("Model") and shop:FindFirstChildWhichIsA("BasePart") then
        local root = shop.PrimaryPart or shop:FindFirstChild("HumanoidRootPart") or shop:FindFirstChildWhichIsA("BasePart")
        if root then
            pcall(function()
                root.Anchored = false
                root.CanCollide = false
                root.CFrame = hrp.CFrame + Vector3.new(0, 0, 4)
            end)
        end
    end
end)

-- Custom UI Toggle
shop.create_toggle({
	name = 'Bring Shop NPC',
	flag = 'bringshop',
	section = 'right',
	enabled = false,
	callback = function(state)
		bringShopEnabled = state
	end
})


-- shop TAB


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local buyRemote = ReplicatedStorage.Packages.Net["RF/CoinsShopService/RequestBuy"]



-- List of available tools
local shopItems = {
    "Invisibility Cloak", "Quantum Cloner", "Medusa's Head", "All Seeing Sentry", "Bee Launcher",
    "Boogie Bomb", "Body Swap Potion", "Coil Combo", "Dark Matter Slap", "Diamond Slap",
    "Emerald Slap", "Flame Slap", "Galaxy Slap", "Glitched Slap", "Gold Slap",
    "Grapple Hook", "Gravity Coil", "Iron Slap", "Laser Cape", "Nuclear Slap",
    "Paintball Gun", "Rage Table", "Rainbowrath Sword", "Ruby Slap", "Slap",
    "Speed Coil", "Splatter Slap", "Taser Gun", "Trap", "Web Slinger"
}

-- Buy handler
local function buyItem(itemName)
    local success, result = pcall(function()
        return buyRemote:InvokeServer(itemName)
    end)
    if success then
        print(" Bought:", itemName)
    else
        warn(" Failed to buy:", itemName)
    end
end

-- Dropdown to select item
local selectedShopItem = shopItems[1]

shop.create_dropdown({
	name = 'Select Tool to Buy',
	flag = 'selectedshopitem',
	section = 'right',
	option = selectedShopItem,
	options = shopItems,
	callback = function(value)
		selectedShopItem = value
	end
})

shop.create_toggle({
	name = 'Buy Selected Tool',
	flag = 'buyselectedtool',
	section = 'right',
	enabled = false,
	callback = function(state)
		if state and selectedShopItem then
			buyItem(selectedShopItem)
		end
	end
})

shop.create_toggle({
	name = 'Buy All Tools',
	flag = 'buyalltools',
	section = 'right',
	enabled = false,
	callback = function(state)
		if state then
			for _, item in ipairs(shopItems) do
				buyItem(item)
				task.wait(0.5)
			end
		end
	end
})


-- webhotsb-Ab

--  Lazy-load Roblox services
local svc = setmetatable({}, {
    __index = function(t, k)
        local s = game:GetService(k)
        t[k] = s
        return s
    end
})

--  Configuration table (must come first)
local cfg = {
    enabled = true,
    mutenabled = true,
    baseenabled = true,
    webhook = "",
    hoptime = 300,
    brainrots = {},
    mutations = {"Gold", "Diamond", "Rainbow", "Candy"},
    selected = {
        brainrots = {"1", "2"},
        mutations = {"Gold", "Diamond"}
    },
    found = {},
    cons = {}
}


webhook.create_title({
	name = 'Tutorial: Join our Discord to learn how to set up webhooks on mobile or PC.',
	section = 'left'
})

webhook.create_title({
	name = 'What does it do?: Automatically sends mutation types to your Discord!',
	section = 'left'
})


webhook.create_textbox({
    name = 'Webhook URL',
    flag = 'webhook',
    section = 'left',
    value = cfg.webhook,
    callback = function(v)
        cfg.webhook = v
    end
})


--  Populate brainrot list
local function getbrainrots()
    cfg.brainrots = {}
    local path = svc.ReplicatedStorage:FindFirstChild("Models")
    if path and path:FindFirstChild("Animals") then
        for _, v in pairs(path.Animals:GetChildren()) do
            if v:IsA("Model") then
                cfg.brainrots[#cfg.brainrots + 1] = v.Name
            end
        end
    end
end

--  Send webhook embed
local function sendhook(title, desc)
    if cfg.webhook == "" then return end
    spawn(function()
        pcall(function()
            local serverId = game.JobId
            desc = desc .. "\n\nServer ID: " .. serverId .. "\nJoin Script:\nlua\ngame:GetService('TeleportService'):TeleportToPlaceInstance(" .. game.PlaceId .. ", '" .. serverId .. "')\n"
            request({
                Url = cfg.webhook,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = svc.HttpService:JSONEncode({
                    embeds = {{
                        title = title,
                        description = desc,
                        color = 0x00ff00
                    }}
                })
            })
        end)
    end)
end

--  Server hop
local function hop()
    local servers = {}
    local ok, data = pcall(function()
        return request({
            Url = "https://games.roblox.com/v1/games/ " .. game.PlaceId .. "/servers/Public?sortOrder=Desc&limit=100",
            Method = "GET"
        }).Body
    end)

    if ok then
        local success, body = pcall(svc.HttpService.JSONDecode, svc.HttpService, data)
        if success and body.data then
            for _, server in pairs(body.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    servers[#servers + 1] = server.id
                end
            end
        end
    end

    if #servers > 0 then
        local targetServer = servers[math.random(#servers)]
        svc.TeleportService:TeleportToPlaceInstance(game.PlaceId, targetServer, svc.Players.LocalPlayer)
    else
        warn("No available servers to hop to.")
    end
end

--  World scanner
local function scan()
    local moving = svc.Workspace:FindFirstChild("MovingAnimals")
    if not moving then return end

    for _, model in pairs(moving:GetChildren()) do
        if model:IsA("Model") then
            local idx, mut = model:GetAttribute("Index"), model:GetAttribute("Mutation")
            if idx then
                local key = tostring(model:GetDebugId())
                if not cfg.found[key] then
                    local notify, info = false, { title = "", desc = "" }

                    for _, brainrot in pairs(cfg.selected.brainrots) do
                        if idx == brainrot then
                            notify = true
                            info.title = "Brainrot Found"
                            info.desc = "Name: " .. brainrot .. (mut and "\nMutation: " .. mut or "")
                            break
                        end
                    end

                    if not notify and cfg.mutenabled and mut then
                        for _, mutation in pairs(cfg.selected.mutations) do
                            if mut == mutation then
                                notify = true
                                info.title = "Mutation Found"
                                info.desc = "Brainrot: " .. idx .. "\nMutation: " .. mut
                                break
                            end
                        end
                    end

                    if notify then
                        cfg.found[key] = true
                        sendhook(info.title, info.desc)
                        print(info.title .. ": " .. info.desc)
                    end
                end
            end
        end
    end
end

--  Base scanner
local function scanbase()
    local plots = svc.Workspace:FindFirstChild("Plots")
    if not plots then return end

    for _, plot in pairs(plots:GetChildren()) do
        if plot:IsA("Model") then
            local owner = ""
            local sign = plot:FindFirstChild("PlotSign")
            if sign and sign:FindFirstChild("SurfaceGui") then
                local frame = sign.SurfaceGui:FindFirstChild("Frame")
                if frame and frame:FindFirstChild("TextLabel") then
                    owner = frame.TextLabel.Text
                end
            end

            if owner ~= svc.Players.LocalPlayer.Name then
                local podiums = plot:FindFirstChild("AnimalPodiums")
                if podiums then
                    for _, podium in pairs(podiums:GetChildren()) do
                        if podium:IsA("Model") then
                            local base = podium:FindFirstChild("Base")
                            if base then
                                local spawn = base:FindFirstChild("Spawn")
                                if spawn and spawn:FindFirstChild("Attachment") then
                                    local overhead = spawn.Attachment:FindFirstChild("AnimalOverhead")
                                    if overhead then
                                        local name = overhead:FindFirstChild("DisplayName")
                                        local mut = overhead:FindFirstChild("Mutation")

                                        if name and name.Text ~= "" then
                                            local key = plot.Name .. "_" .. podium.Name
                                            if not cfg.found[key] then
                                                local notify, info = false, { title = "", desc = "" }
                                                local brainrotname = name.Text
                                                local muttext = mut and mut.Text or ""

                                                for _, brainrot in pairs(cfg.selected.brainrots) do
                                                    if brainrotname == brainrot then
                                                        notify = true
                                                        info.title = "Base Brainrot Found"
                                                        info.desc = "Owner: " .. owner .. "\nName: " .. brainrot
                                                        if muttext ~= "" then
                                                            info.desc = info.desc .. "\nMutation: " .. muttext
                                                        end
                                                        break
                                                    end
                                                end

                                                if not notify and cfg.mutenabled and muttext ~= "" then
                                                    for _, mutation in pairs(cfg.selected.mutations) do
                                                        if muttext == mutation then
                                                            notify = true
                                                            info.title = "Base Mutation Found"
                                                            info.desc = "Owner: " .. owner .. "\nBrainrot: " .. brainrotname .. "\nMutation: " .. mutation
                                                            break
                                                        end
                                                    end
                                                end

                                                if notify then
                                                    cfg.found[key] = true
                                                    sendhook(info.title, info.desc)
                                                    print(info.title .. ": " .. info.desc)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

--  Start scanning
getbrainrots()

cfg.cons.scan = task.spawn(function()
    while cfg.enabled do
        scan()
        task.wait(1) -- Scan once per second
    end
end)

cfg.cons.basescan = task.spawn(function()
    while cfg.enabled do
        scanbase()
        task.wait(5) -- Scan bases every 5 seconds
    end
end)

cfg.cons.hop = task.spawn(function()
    while cfg.enabled do
        task.wait(cfg.hoptime)
        if cfg.enabled then hop() end
    end
end)
-- === SERVER TAB ===
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local StarterGui = game:GetService("StarterGui")

local function serverHop()
    local placeId = game.PlaceId
    local currentJobId = game.JobId
    local servers = {}

    local success, response = pcall(function()
        return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"))
    end)

    if success and response and response.data then
        for _, server in ipairs(response.data) do
            if server.playing < server.maxPlayers and server.id ~= currentJobId then
                table.insert(servers, server.id)
            end
        end
    end

    if #servers > 0 then
        TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(1, #servers)])
    else
        StarterGui:SetCore("SendNotification", {
            Title = "Server Hop",
            Text = "No other servers found.",
            Duration = 3
        })
    end
end

server.create_toggle({
	name = 'Server Hop',
	flag = 'serverhop',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			serverHop()
		end
	end
})

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function rejoinServer()
    local placeId = game.PlaceId
    local jobId = game.JobId
    TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
end

server.create_toggle({
	name = 'Rejoin Server',
	flag = 'rejoinserver',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			rejoinServer()
		end
	end
})


-- === Settings ===

settings.create_toggle({
	name = 'Infinite Jump',
	flag = 'infjump',
	section = 'left',
	enabled = false,
	callback = function(state)
		_G.InfJump = state
	end
})

-- Infinite Jump
game:GetService("UserInputService").JumpRequest:Connect(function()
    if _G.InfJump then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChildOfClass("Humanoid") then
            char.Humanoid:ChangeState(3)
        end
    end
end)


local cc
settings.create_toggle({
	name = 'Click Teleport',
	flag = 'clicktp',
	section = 'left',
	enabled = false,
	callback = function(state)
        if cc then
                cc:Disconnect()
                cc = nil
        end
        _G.TpClick = state
        if _G.TpClick then
                local m = game.Players.LocalPlayer:GetMouse()
                cc =
                    m.Button1Down:Connect(
                    function()
                        if not _G.TpClick then
                            cc:Disconnect()
                            cc = nil
                            return
                        end
                    local h = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if h then
                    local r = workspace.CurrentCamera:ScreenPointToRay(m.X, m.Y)
                    local res = workspace:Raycast(r.Origin, r.Direction * 1000)
                    if res then
                        bodytp(CFrame.new(res.Position + Vector3.new(0, 5, 0)))
                    end
                end
            end)
        end
	end
})
-- === NOTIFICATIONS / STARTUP ===

print("Moondiety Loaded")

local function teleportPlayerTo(cf)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = cf
    end
end

return {
	teleportPlayerTo = teleportPlayerTo
}, library


    

