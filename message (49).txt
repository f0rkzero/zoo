-- Anti Cheat Bypasser
local mt = getrawmetatable(game)
setreadonly(mt, false)

local oldNamecall = mt.__namecall

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    
    if method == "Kick" or tostring(self) == "Kick" then
        warn("[AntiKick] Kick attempt blocked.")
        return nil
    end

    return oldNamecall(self, unpack(args))
end)


-- Library Initializer

getgenv().namehub='Steal A BrainRot - Moondiety'

local init = loadstring(game:HttpGet("https://raw.githubusercontent.com/goondiety/ESP-LIB/refs/heads/main/uiloader.txt"))()


-- Services & Utils
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local function bodytp(cf)
    local hrp = (game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1/0, 1/0, 1/0)
    bv.Parent = hrp
    local fin = false
    local con
    con = game:GetService("RunService").Heartbeat:Connect(function()
        local dir = (cf.Position - hrp.Position)
        if dir.Magnitude < 2 then
            bv.Velocity = Vector3.zero
            hrp.CFrame = cf
            con:Disconnect()
            bv:Destroy()
            fin = true
        else
            bv.Velocity = dir.Unit * 35
        end
    end)
    repeat task.wait() until fin
end



function braincollect()
        for _, x in ipairs(game.Workspace.Plots:GetChildren()) do
            local txt = x.PlotSign.SurfaceGui.Frame.TextLabel.Text
            if x:FindFirstChild("PlotSign") and txt:find(game.Players.LocalPlayer.Name) then
                local char = game.Players.LocalPlayer.Character
                local currenth = char.Humanoid.HipHeight
                if char and char:FindFirstChild("Humanoid") then
                    char.Humanoid.HipHeight = 100
                end
                bodytp(x.Multiplier.CFrame)
                if char and char:FindFirstChild("Humanoid") then
                    char.Humanoid.HipHeight = currenth
                end
            end
        end
    end


function walkto(Cframe)
game.Players.LocalPlayer.Character.Humanoid:MoveTo(Cframe.Position)
end

-- Script Init

local Lib = init.new()
local home = Lib:create_tab('Home', "10723407389")
local main = Lib:create_tab('Main', "10709797837")
local esp = Lib:create_tab('ESP', "10723346959")
local auto = Lib:create_tab('Auto', "10734950309")
local utility = Lib:create_tab('Utility', "10747373821")
local shop = Lib:create_tab('Shop', "10734952479")
local webhook = Lib:create_tab('Webhook', "10723426722")

home.create_title({
	name = 'Credits: Steal A BrainRot Moondiety',
	section = 'left'
})

home.create_button({
    name = 'Join Discord like a GOOD BOY',
    section = 'left',
    enabled = false,
    callback = function()
        setclipboard('https://discord.gg/moondiety')
    end
})

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local StarterGui = game:GetService("StarterGui")

local function serverHop()
    local placeId = game.PlaceId
    local currentJobId = game.JobId
    local servers = {}

    local success, response = pcall(function()
        return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"))
    end)

    if success and response and response.data then
        for _, server in ipairs(response.data) do
            if server.playing < server.maxPlayers and server.id ~= currentJobId then
                table.insert(servers, server.id)
            end
        end
    end

    if #servers > 0 then
        TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(1, #servers)])
    else
        StarterGui:SetCore("SendNotification", {
            Title = "Server Hop",
            Text = "No other servers found.",
            Duration = 3
        })
    end
end

home.create_toggle({
	name = 'Server Hop',
	flag = 'serverhop',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			serverHop()
		end
	end
})

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function rejoinServer()
    local placeId = game.PlaceId
    local jobId = game.JobId
    TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
end

home.create_toggle({
	name = 'Rejoin Server',
	flag = 'rejoinserver',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			rejoinServer()
		end
	end
})


local Players = game:GetService("Players")
local player = Players.LocalPlayer

local godMode = false
local godConnection = nil

main.create_toggle({
	name = 'God Mode',
	flag = 'godmode',
	section = 'left',
	enabled = false,
	callback = function(state)
		godMode = state
		local char = player.Character
		if not char then return end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum then return end
		if godConnection then
			godConnection:Disconnect()
			godConnection = nil
		end
		if godMode then
			hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
			hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
			godConnection = hum.StateChanged:Connect(function(_, s)
				if s == Enum.HumanoidStateType.Dead then
					hum:ChangeState(Enum.HumanoidStateType.Running)
				end
			end)
		else
			hum:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
			hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
		end
	end
})


-- === WALK SPEED ===
-- === MAIN TAB ===

local player = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local currentSpeed = 0

local function sSpeed(character)
    local hum = character:WaitForChild("Humanoid")
    local hb = RunService.Heartbeat
    task.spawn(function()
        while character and hum and hum.Parent and _G.BoostOn do
            if currentSpeed > 0 and hum.MoveDirection.Magnitude > 0 and _G.BoostOn then
                character:TranslateBy(hum.MoveDirection * currentSpeed * hb:Wait())
            end
            task.wait()
        end
    end)
end

local function onCharacterAdded(character)
    sSpeed(character)
end

player.CharacterAdded:Connect(onCharacterAdded)
if player.Character and _G.BoostOn then
    onCharacterAdded(player.Character)
end

main.create_toggle({
	name = 'Activate Speed Boost',
	flag = 'spboost',
	section = 'left',
	enabled = false,
	callback = function(state)
        _G.BoostOn = state
	end
})

main.create_slider({
	name = 'Speed Boost',
	flag = 'speedboost',
	section = 'left',
	value = 5,
	minimum_value = 1,
	maximum_value = 15,
	callback = function(value)
		currentSpeed = value
	end
})


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local buyRemote = ReplicatedStorage.Packages.Net["RF/CoinsShopService/RequestBuy"]

local charConn = nil
local speedBoostEnabled = false

local function equipSpeedCoil()
	local backpack = player:FindFirstChild("Backpack")
	local char = player.Character
	if not (backpack and char) then return end

	local item = backpack:FindFirstChild("Speed Coil") or char:FindFirstChild("Speed Coil")
	if not item then
		pcall(function() buyRemote:InvokeServer("Speed Coil") end)
		item = backpack:WaitForChild("Speed Coil", 2)
	end
	if not item then return end

	item.Parent = char
end

local function enableBypassSpeed()
	if charConn then charConn:Disconnect() end
	charConn = player.CharacterAdded:Connect(equipSpeedCoil)
	if player.Character then equipSpeedCoil() end
end

local function disableBypassSpeed()
	if charConn then charConn:Disconnect() end
	charConn = nil
end


main.create_toggle({
	name = 'Speed Boost v2',
	flag = 'speedboostv2',
	section = 'left',
	enabled = false,
	callback = function(state)
		speedBoostEnabled = state
		if state then
			enableBypassSpeed()
		else
			disableBypassSpeed()
		end
	end
})


main.create_button({
	name = 'Steal BrainRot',
	section = 'left',
    enabled = false,
	callback = function()
		local hrp = (game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
		local cam = game:GetService("Workspace").CurrentCamera
		local backup_cframe = hrp.CFrame + Vector3.new(0, 55, 0)
		local intp = false
		local lasttp_timer = 0

		local function toroof()
			if intp or tick() - lasttp_timer < 3 then return end
			intp = true
			lasttp_timer = tick()
			local goalcf = hrp.CFrame + Vector3.new(0, 55, 0)
			cam.CameraType = Enum.CameraType.Scriptable
			cam.CFrame = goalcf
			local void = hrp.CFrame + Vector3.new(0, -450000, 0)
			for _ = 1, 5 do
				task.spawn(function()
					hrp.CFrame = goalcf
					task.wait(0.1)
					hrp.CFrame = void
					task.wait(0.1)
					hrp.CFrame = goalcf
				end)
			end
			task.wait(0.5)
			cam.CameraType = Enum.CameraType.Custom
			intp = false
		end

		task.wait(2)
		while true do
			local dist = (hrp.Position - backup_cframe.Position).Magnitude
			if dist > 30 then
				toroof()
			else
				break
			end
			task.wait(3)
		end
		braincollect()
	end
})


main.create_button({
	name = 'Teleport to Roof',
	section = 'left',
    enabled = false,
	callback = function()
		local hrp = (game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")
		local cam = game:GetService("Workspace").CurrentCamera
		local intp = false
		local lasttp_timer = 0
		if intp then return end
		if tick() - lasttp_timer < 3 then return end
		intp = true
		lasttp_timer = tick()
		local goalcf = hrp.CFrame + Vector3.new(0, 55, 0)
		cam.CameraType = Enum.CameraType.Scriptable
		cam.CFrame = goalcf
		local void = hrp.CFrame + Vector3.new(0, -400000, 0)
		for _ = 1, 5 do
			task.spawn(function()
				hrp.CFrame = goalcf
				task.wait(0.1)
				hrp.CFrame = void
				task.wait(0.1)
				hrp.CFrame = goalcf
			end)
		end
		task.wait(0.5)
		cam.CameraType = Enum.CameraType.Custom
		intp = false
	end
})

main.create_button({
	name = 'Walk to Base',
	flag = 'walkbase',
	section = 'left',
	enabled = false,
	callback = function()
       for _, x in ipairs(game.Workspace.Plots:GetChildren()) do
    if x:FindFirstChild("PlotSign") and x.PlotSign.SurfaceGui.Frame.TextLabel.Text:find(game.Players.LocalPlayer.Name) then
        walkto(x.Multiplier.CFrame)
    end
end

	end
})


local noclip_enabled = false
local lastPosition = nil
local threshold = 10

main.create_toggle({
	name = 'Noclip',
	flag = 'noclip',
	section = 'left',
	enabled = false,
	callback = function(state)
		noclip_enabled = state
	end
})

game:GetService("RunService").Stepped:Connect(function()
	if noclip_enabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		local char = player.Character
		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end

		local hrp = char:FindFirstChild("HumanoidRootPart")
		if hrp then
			local currentPos = hrp.Position
			if lastPosition then
				local distance = (currentPos - lastPosition).Magnitude
				if distance > threshold then
					hrp.CFrame = CFrame.new(lastPosition)
				else
					lastPosition = currentPos
				end
			else
				lastPosition = currentPos
			end
		end
	end
end)


local player = game:GetService("Players").LocalPlayer  
local RunService = game:GetService("RunService")  
local UserInputService = game:GetService("UserInputService")

local boostConnection = nil  
local char = player.Character or player.CharacterAdded:Wait()  
local root = char:WaitForChild("HumanoidRootPart")  
local humanoid = char:WaitForChild("Humanoid")  
  
local function enableJumpBoost()  
    char = player.Character or player.CharacterAdded:Wait()  
    root = char:WaitForChild("HumanoidRootPart")  
    humanoid = char:WaitForChild("Humanoid")  

    player.CharacterAdded:Connect(function(newChar)  
        char = newChar  
        root = char:WaitForChild("HumanoidRootPart")  
        humanoid = char:WaitForChild("Humanoid")  
    end)  

    boostConnection = RunService.Stepped:Connect(function()  
        if not char or not humanoid or not root then return end  

        if humanoid:GetState() == Enum.HumanoidStateType.Freefall then  
            root.Velocity = Vector3.new(  
                root.Velocity.X,  
                math.clamp(root.Velocity.Y, -20, 150),  
                root.Velocity.Z  
            )  
        end  
    end)  

    UserInputService.JumpRequest:Connect(function()  
        if humanoid and root then  
            root.AssemblyLinearVelocity = Vector3.new(0, 100, 0)  
        end  
    end)  
end  

  
local function disableJumpBoost()  
    if boostConnection then  
        boostConnection:Disconnect()  
        boostConnection = nil  
    end  
end  


main.create_toggle({
	name = 'Smooth Jump',
	flag = 'smoothjump',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			enableJumpBoost()
		else
			disableJumpBoost()
		end
	end
})


local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local Players = game:GetService("Players")

local Player = Players.LocalPlayer
local Connections = {}
local AirJumpEnabled = false

-- Setup Jump Logic
Connections.JumpButton = nil

local function enableSmoothJump()
    if Connections.JumpButton then return end

    Connections.JumpButton = UserInputService.JumpRequest:Connect(function()
        if not AirJumpEnabled then return end

        local character = Player.Character
        if not character then return end

        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")

        if humanoid and rootPart and humanoid.FloorMaterial == Enum.Material.Air then
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
            bodyVelocity.Velocity = Vector3.new(0, 65, 0)
            bodyVelocity.Parent = rootPart
            Debris:AddItem(bodyVelocity, 0.3)
        end
    end)
end

local function disableSmoothJump()
    if Connections.JumpButton then
        Connections.JumpButton:Disconnect()
        Connections.JumpButton = nil
    end
end


main.create_toggle({
	name = 'Smooth Jump v2',
	flag = 'smoothjumpv2',
	section = 'left',
	enabled = false,
	callback = function(state)
		AirJumpEnabled = state
		if state then
			enableSmoothJump()
		else
			disableSmoothJump()
		end
	end
})


local Players = game:GetService("Players")
local player = Players.LocalPlayer
local floatForce = Vector3.new(0, 40, 0)
local bodyVelocity = nil

main.create_toggle({
	name = 'Fly',
	flag = 'fly',
	section = 'left',
	enabled = false,
	callback = function(enabled)
		local character = player.Character or player.CharacterAdded:Wait()
		local root = character:WaitForChild("HumanoidRootPart")

		if enabled then
			bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.Name = "FloatForce"
			bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
			bodyVelocity.Velocity = floatForce
			bodyVelocity.Parent = root

			character:WaitForChild("Humanoid").Died:Connect(function()
				if bodyVelocity then
					bodyVelocity:Destroy()
					bodyVelocity = nil
				end
			end)
		else
			if bodyVelocity then
				bodyVelocity:Destroy()
				bodyVelocity = nil
			end
		end
	end
})


main.create_toggle({
	name = 'Infinite Jump',
	flag = 'infjump',
	section = 'left',
	enabled = false,
	callback = function(state)
		_G.InfJump = state
	end
})

-- Infinite Jump
game:GetService("UserInputService").JumpRequest:Connect(function()
    if _G.InfJump then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChildOfClass("Humanoid") then
            char.Humanoid:ChangeState(3)
        end
    end
end)


local cc
main.create_toggle({
	name = 'Click Teleport',
	flag = 'clicktp',
	section = 'left',
	enabled = false,
	callback = function(state)
        if cc then
                cc:Disconnect()
                cc = nil
        end
        _G.TpClick = state
        if _G.TpClick then
                local m = game.Players.LocalPlayer:GetMouse()
                cc =
                    m.Button1Down:Connect(
                    function()
                        if not _G.TpClick then
                            cc:Disconnect()
                            cc = nil
                            return
                        end
                    local h = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if h then
                    local r = workspace.CurrentCamera:ScreenPointToRay(m.X, m.Y)
                    local res = workspace:Raycast(r.Origin, r.Direction * 1000)
                    if res then
                        bodytp(CFrame.new(res.Position + Vector3.new(0, 5, 0)))
                    end
                end
            end)
        end
	end
})

-- === ESP SYSTEM ===
local espEnabled = false
local espInstances = {}

local function createESP(player)
    if not espEnabled then return end
    if player == Players.LocalPlayer then return end

    local character = player.Character
    if not character then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 10)
    if not humanoidRootPart then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_" .. player.Name
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 200, 0, 30)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.Adornee = humanoidRootPart
    billboard.Parent = humanoidRootPart

    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "NameLabel"
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = player.DisplayName
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    textLabel.TextStrokeTransparency = 0
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Parent = billboard

    espInstances[player] = billboard

    local function onCharacterAdded(newCharacter)
        if billboard then billboard:Destroy() end
        local newHRP = newCharacter:WaitForChild("HumanoidRootPart", 10)
        if newHRP and espEnabled then
            billboard.Adornee = newHRP
            billboard.Parent = newHRP
        end
    end
    player.CharacterAdded:Connect(onCharacterAdded)
end

local function removeESP(player)
    local espInstance = espInstances[player]
    if espInstance then
        espInstance:Destroy()
        espInstances[player] = nil
    end
end

local function toggleESP(enable)
    espEnabled = enable
    if enable then
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= player then
                coroutine.wrap(function()
                    createESP(p)
                end)()
            end
        end
    else
        for _, espInstance in pairs(espInstances) do
            if espInstance then
                espInstance:Destroy()
            end
        end
        espInstances = {}
    end
end

local function initPlayerConnections()
    Players.PlayerAdded:Connect(function(p)
        p.CharacterAdded:Connect(function(character)
            if p ~= player and espEnabled then
                task.wait(1)
                createESP(p)
            end
        end)
    end)
    Players.PlayerRemoving:Connect(removeESP)
end
initPlayerConnections()

-- === RARITY & MUTATION ESP SETTINGS ===
local RaritySettings = {
    ["Legendary"] = { Color = Color3.fromRGB(255, 215, 0), Size = UDim2.new(0, 150, 0, 50) },
    ["Mythic"] = { Color = Color3.fromRGB(138, 43, 226), Size = UDim2.new(0, 150, 0, 60) },
    ["Brainrot God"] = { Color = Color3.fromRGB(255, 0, 0), Size = UDim2.new(0, 180, 0, 60) },
    ["Secret"] = { Color = Color3.fromRGB(255, 20, 147), Size = UDim2.new(0, 200, 0, 70) }
}

local MutationSettings = {
    ["Gold"] = { Color = Color3.fromRGB(255, 215, 0), Size = UDim2.new(0, 120, 0, 30) },
    ["Diamond"] = { Color = Color3.fromRGB(185, 242, 255), Size = UDim2.new(0, 120, 0, 30) },
    ["Rainbow"] = { Color = Color3.fromRGB(255, 0, 255), Size = UDim2.new(0, 120, 0, 30) },
    ["Bloodrot"] = { Color = Color3.fromRGB(139, 0, 0), Size = UDim2.new(0, 120, 0, 30) }
}

local activeESP = {}
local activeLockTimeEsp = false
local lteInstances = {}

local myPlotName
for _, plot in ipairs(workspace.Plots:GetChildren()) do
    if plot:FindFirstChild("YourBase", true) and plot:FindFirstChild("YourBase", true).Enabled then
        myPlotName = plot.Name
        break
    end
end

local function getOwner(plot)
    local text = plot:FindFirstChild("PlotSign") and
        plot.PlotSign:FindFirstChild("SurfaceGui") and
        plot.PlotSign.SurfaceGui.Frame.TextLabel.Text or "Unknown"
    return text:match("^(.-)'s Base") or text
end

local function updatelock()
    if not activeLockTimeEsp then
        for _, instance in pairs(lteInstances) do
            if instance then
                instance:Destroy()
            end
        end
        lteInstances = {}
        return
    end

    for _, plot in pairs(workspace.Plots:GetChildren()) do
        local timeLabel = plot:FindFirstChild("Purchases", true) and
            plot.Purchases:FindFirstChild("PlotBlock", true) and
            plot.Purchases.PlotBlock.Main:FindFirstChild("BillboardGui", true) and
            plot.Purchases.PlotBlock.Main.BillboardGui:FindFirstChild("RemainingTime", true)

        if timeLabel and timeLabel:IsA("TextLabel") then
            local espName = "LockTimeESP_" .. plot.Name
            local existingBillboard = plot:FindFirstChild(espName)

            local isUnlocked = timeLabel.Text == "0s"
            local displayText = isUnlocked and "Unlocked" or ("Lock: " .. timeLabel.Text)

            local textColor = isUnlocked and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)

            if not existingBillboard then
                local billboard = Instance.new("BillboardGui")
                billboard.Name = espName
                billboard.Size = UDim2.new(0, 200, 0, 30)
                billboard.StudsOffset = Vector3.new(0, 5, 0)
                billboard.AlwaysOnTop = true
                billboard.Adornee = plot.Purchases.PlotBlock.Main

                local label = Instance.new("TextLabel")
                label.Text = displayText
                label.Size = UDim2.new(1, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.TextScaled = true
                label.TextColor3 = textColor
                label.TextStrokeColor3 = Color3.new(0, 0, 0)
                label.TextStrokeTransparency = 0
                label.Font = Enum.Font.SourceSansBold
                label.Parent = billboard

                billboard.Parent = plot
                lteInstances[plot.Name] = billboard
            else
                existingBillboard.TextLabel.Text = displayText
                existingBillboard.TextLabel.TextColor3 = textColor
            end
        end
    end
end

local function updateRESP()
    for _, plot in pairs(workspace.Plots:GetChildren()) do
        if plot.Name ~= myPlotName then
            for _, child in pairs(plot:GetDescendants()) do
                if child.Name == "Rarity" and child:IsA("TextLabel") and RaritySettings[child.Text] then
                    local parentModel = child.Parent.Parent
                    local espName = child.Text .. "_ESP"
                    local mutationEspName = "Mutation_ESP"
                    local existingBillboard = parentModel:FindFirstChild(espName)
                    local existingMutationBillboard = parentModel:FindFirstChild(mutationEspName)

                    if activeESP[child.Text] then
                        if not existingBillboard then
                            local settings = RaritySettings[child.Text]

                            local billboard = Instance.new("BillboardGui")
                            billboard.Name = espName
                            billboard.Size = settings.Size
                            billboard.StudsOffset = Vector3.new(0, 3, 0)
                            billboard.AlwaysOnTop = true
                            billboard.Adornee = parentModel

                            local label = Instance.new("TextLabel")
                            label.Text = child.Parent.DisplayName.Text
                            label.Size = UDim2.new(1, 0, 1, 0)
                            label.BackgroundTransparency = 1
                            label.TextScaled = true
                            label.TextColor3 = settings.Color
                            label.TextStrokeColor3 = Color3.new(0, 0, 0)
                            label.TextStrokeTransparency = 0
                            label.Font = Enum.Font.SourceSansBold
                            label.Parent = billboard

                            billboard.Parent = parentModel
                        end

                        local mutation = child.Parent:FindFirstChild("Mutation")
                        if mutation and mutation:IsA("TextLabel") and MutationSettings[mutation.Text] then
                            local mutationSettings = MutationSettings[mutation.Text]

                            if not existingMutationBillboard then
                                local mutationBillboard = Instance.new("BillboardGui")
                                mutationBillboard.Name = mutationEspName
                                mutationBillboard.Size = mutationSettings.Size
                                mutationBillboard.StudsOffset = Vector3.new(0, 6, 0)
                                mutationBillboard.AlwaysOnTop = true
                                mutationBillboard.Adornee = parentModel

                                local mutationLabel = Instance.new("TextLabel")
                                mutationLabel.Text = mutation.Text
                                mutationLabel.Size = UDim2.new(1, 0, 1, 0)
                                mutationLabel.BackgroundTransparency = 1
                                mutationLabel.TextScaled = true
                                mutationLabel.TextColor3 = mutationSettings.Color
                                mutationLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
                                mutationLabel.TextStrokeTransparency = 0
                                mutationLabel.Font = Enum.Font.SourceSansBold
                                mutationLabel.Parent = mutationBillboard

                                mutationBillboard.Parent = parentModel
                            else
                                existingMutationBillboard.TextLabel.Text = mutation.Text
                                existingMutationBillboard.TextLabel.TextColor3 = mutationSettings.Color
                            end
                        elseif existingMutationBillboard then
                            existingMutationBillboard:Destroy()
                        end
                    else
                        if existingBillboard then existingBillboard:Destroy() end
                        if existingMutationBillboard then existingMutationBillboard:Destroy() end
                    end
                end
            end
        end
    end
end

-- === PET FINDER DROPDOWN ===
local petModels = ReplicatedStorage.Models.Animals:GetChildren()

local petNames = {}
for _, pet in ipairs(petModels) do
    table.insert(petNames, pet.Name)
end

local sel = nil
local run = false

esp.create_multidropdown({
   name = 'Find Pets',
   flag = 'findpets',
   section = 'left',
   options = petNames,
   callback = function(val)
   	sel = val
   	if run then return end
   	run = true
   	task.spawn(function()
   		while #sel > 0 do
   			local foundPets = {}
   			for _, p in pairs(workspace.Plots:GetChildren()) do
   				if p.Name ~= myPlotName then
   					local own = getOwner(p)
   					for _, v in pairs(p:GetDescendants()) do
   						if v.Name == "DisplayName" then
   							for _, selectedPet in pairs(sel) do
   								if v.Text == selectedPet then
   									table.insert(foundPets, selectedPet.." | Owner: "..own)
   								end
   							end
   						end
   					end
   				end
   			end
   			
   			if #foundPets > 0 then
   				warn("Found pets: " .. table.concat(foundPets, " | "))
   			else
   				warn("No choosen pets found")
   			end
   			task.wait(.5)
   		end
   		run = false
   	end)
   end
})

-- === ESP TYPES MULTIDROPDOWN ===
esp.create_multidropdown({
   name = 'ESP',
   flag = 'ESPTypesDropdown',
   section = 'left',
   options = {'Lock', 'Players', 'Legendary', 'Mythic', 'Brainrot God', 'Secret'},
   callback = function(values)
   	local hasPlayers = false
   	
   	for _, value in values do
   		if value == "Players" then
   			hasPlayers = true
   			break
   		end
   	end
   	
   	toggleESP(hasPlayers)
   	
   	activeESP["Legendary"] = false
   	activeESP["Mythic"] = false
   	activeESP["Brainrot God"] = false
   	activeESP["Secret"] = false
   	activeLockTimeEsp = false
   	
   	for _, value in values do
   		if value == "Legendary" then
   			activeESP["Legendary"] = true
   		elseif value == "Mythic" then
   			activeESP["Mythic"] = true
   		elseif value == "Brainrot God" then
   			activeESP["Brainrot God"] = true
   		elseif value == "Secret" then
   			activeESP["Secret"] = true
   		elseif value == "Lock" then
   			activeLockTimeEsp = true
   		end
   	end
   	
   	updatelock()
   	updateRESP()
   end
})

task.spawn(function()
   while true do
   	task.wait(0.25)
   	if activeLockTimeEsp then updatelock() end
   	if next(activeESP) ~= nil then updateRESP() end
   end
end)



local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local plotTimers_Enabled = false
local plotTimers_Coroutine = nil
local plotTimers_RenderConnections = {}
local plotTimers_OriginalProperties = {}

-- Disable logic
local function disablePlotTimers()
    plotTimers_Enabled = false
    if plotTimers_Coroutine then
        task.cancel(plotTimers_Coroutine)
        plotTimers_Coroutine = nil
    end
    for _, conn in pairs(plotTimers_RenderConnections) do
        pcall(function() conn:Disconnect() end)
    end
    table.clear(plotTimers_RenderConnections)
    for label, props in pairs(plotTimers_OriginalProperties) do
        pcall(function()
            if label and label.Parent then
                local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
                if bb and bb.Parent then
                    bb.Enabled = props.bb_enabled
                    bb.AlwaysOnTop = props.bb_alwaysOnTop
                    bb.Size = props.bb_size
                    bb.MaxDistance = props.bb_maxDistance
                    label.TextScaled = props.label_textScaled
                    label.TextWrapped = props.label_textWrapped
                    label.AutomaticSize = props.label_automaticSize
                    label.Size = props.label_size
                    label.TextSize = props.label_textSize
                end
            end
        end)
    end
    table.clear(plotTimers_OriginalProperties)
end

-- Enable logic
local function enablePlotTimers()
    disablePlotTimers()
    plotTimers_Enabled = true
    plotTimers_Coroutine = task.spawn(function()
        local camera = Workspace.CurrentCamera
        local DISTANCE_THRESHOLD = 45
        local SCALE_START, SCALE_RANGE = 100, 300
        local MIN_TEXT_SIZE, MAX_TEXT_SIZE = 30, 36

        while plotTimers_Enabled do
            pcall(function()
                for _, label in ipairs(Workspace.Plots:GetDescendants()) do
                    if label:IsA("TextLabel") and label.Name == "RemainingTime" then
                        if plotTimers_RenderConnections[label] then continue end
                        local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
                        if not bb then continue end
                        local model = bb:FindFirstAncestorWhichIsA("Model")
                        if not model then continue end
                        local basePart = model:FindFirstChildWhichIsA("BasePart", true)
                        if not basePart then continue end

                        if not plotTimers_OriginalProperties[label] then
                            plotTimers_OriginalProperties[label] = {
                                bb_enabled = bb.Enabled,
                                bb_alwaysOnTop = bb.AlwaysOnTop,
                                bb_size = bb.Size,
                                bb_maxDistance = bb.MaxDistance,
                                label_textScaled = label.TextScaled,
                                label_textWrapped = label.TextWrapped,
                                label_automaticSize = label.AutomaticSize,
                                label_size = label.Size,
                                label_textSize = label.TextSize,
                            }
                        end

                        bb.MaxDistance = 10000
                        bb.AlwaysOnTop = true
                        bb.ClipsDescendants = false
                        bb.Size = UDim2.new(0, 300, 0, 150)
                        label.TextScaled = false
                        label.TextWrapped = true
                        label.ClipsDescendants = false
                        label.Size = UDim2.new(1, 0, 0, 32)
                        label.AutomaticSize = Enum.AutomaticSize.Y

                        local conn = RunService.RenderStepped:Connect(function()
                            if not basePart or not basePart.Parent or not bb or not bb.Parent then
                                if plotTimers_RenderConnections[label] then
                                    plotTimers_RenderConnections[label]:Disconnect()
                                    plotTimers_RenderConnections[label] = nil
                                end
                                return
                            end
                            local distance = (camera.CFrame.Position - basePart.Position).Magnitude
                            if distance > DISTANCE_THRESHOLD and basePart.Position.Y >= 0 then
                                bb.Enabled = false
                                return
                            end
                            bb.Enabled = true
                            local t = math.clamp((distance - SCALE_START) / SCALE_RANGE, 0, 1)
                            local newTextSize = math.clamp(MIN_TEXT_SIZE + (MAX_TEXT_SIZE - MIN_TEXT_SIZE) * t, MIN_TEXT_SIZE, MAX_TEXT_SIZE)
                            label.TextSize = newTextSize
                            label.Size = UDim2.new(1, 0, 0, newTextSize + 6)
                        end)

                        plotTimers_RenderConnections[label] = conn
                    end
                end
            end)
            task.wait(1)
        end
    end)
end

-- GUI Toggle
esp.create_toggle({
	name = 'Esp lock timer base',
	flag = 'baselocktimer',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			enablePlotTimers()
		else
			disablePlotTimers()
		end
	end
})


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer


local AnimalsModule = require(ReplicatedStorage.Datas.Animals)
local TraitsModule = require(ReplicatedStorage.Datas.Traits)
local MutationsModule = require(ReplicatedStorage.Datas.Mutations)
local PlotController = require(ReplicatedStorage.Controllers:WaitForChild("PlotController"))


local espEnabled = false
local isPetScanRunning = false
local highestGenAnimal = nil
local INTERVAL = 0.25

-- All valid pet names
local ALL_ANIMAL_NAMES = {}
for k, _ in pairs(AnimalsModule) do
    ALL_ANIMAL_NAMES[k] = true
end

local function formatNumber(n)
    return tostring(n):reverse():gsub('%d%d%d', '%1,'):reverse():gsub('^,', '')
end

local function isBasePet(m)
    return m:IsA("Model") and ALL_ANIMAL_NAMES[m.Name]
end

local function getMyPlot()
    local ok, result = pcall(function()
        return PlotController:GetMyPlot()
    end)
    return ok and result and result.PlotModel or nil
end

local function isInEnemyPlot(model)
    local myPlot = getMyPlot()
    return not (myPlot and myPlot:IsAncestorOf(model))
end

local function getTraitMultiplier(model)
    local traitJson = (model:FindFirstChild("Instance") or model):GetAttribute("Traits")
    if not traitJson then return 1 end

    local success, traitList = pcall(function()
        return HttpService:JSONDecode(traitJson)
    end)
    if not success or typeof(traitList) ~= "table" then return 1 end

    local mult = 1
    for _, traitName in ipairs(traitList) do
        local trait = TraitsModule[traitName]
        if trait and trait.MultiplierModifier then
            mult *= trait.MultiplierModifier
        end
    end
    return mult
end

local function getMutationMultiplier(model)
    local mutation = model:GetAttribute("Mutation")
    local data = mutation and MutationsModule[mutation]
    return (data and data.MultiplierModifier) or 1
end

local function getFinalGeneration(model)
    local animalData = AnimalsModule[model.Name]
    if not animalData then return 0 end

    local baseGen = animalData.Generation or 0
    local traitMult = getTraitMultiplier(model)
    local mutationMult = getMutationMultiplier(model)
    return math.round(baseGen * traitMult * mutationMult)
end


local function startRainbow(obj, prop)
    local cycleTime = 4
    task.spawn(function()
        while obj and obj.Parent do
            local h = (tick() % cycleTime) / cycleTime
            obj[prop] = Color3.fromHSV(h, 1, 1)
            RunService.Heartbeat:Wait()
        end
    end)
end

local function clearPetESP()
    for _, m in ipairs(workspace:GetChildren()) do
        if m:FindFirstChild("PetESP") then m.PetESP:Destroy() end
        if m:FindFirstChild("PetESP_Label") then m.PetESP_Label:Destroy() end
    end
end

local function attachPetESP(m, g)
    local root = m:FindFirstChild("RootPart") or m:FindFirstChildWhichIsA("BasePart")
    if not root then return end

    local hl = Instance.new('Highlight')
    hl.Name = "PetESP"
    hl.Adornee = m
    hl.OutlineColor = Color3.new(0, 0, 0)
    hl.FillTransparency = 0.25
    hl.OutlineTransparency = 0
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Parent = m
    startRainbow(hl, "FillColor")
    startRainbow(hl, "OutlineColor")

    local gui = Instance.new('BillboardGui')
    gui.Name = "PetESP_Label"
    gui.Adornee = root
    gui.AlwaysOnTop = true
    gui.Size = UDim2.new(0, 400, 0, 80)
    gui.StudsOffset = Vector3.new(0, 6.5, 0)
    gui.Parent = m

    local nameLabel = Instance.new('TextLabel')
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0.5, 0, 0.35, 0)
    nameLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Font = Enum.Font.GothamBlack
    nameLabel.TextSize = 22
    nameLabel.Text = m.Name:upper()
    nameLabel.TextXAlignment = Enum.TextXAlignment.Center
    nameLabel.Parent = gui
    startRainbow(nameLabel, "TextColor3")

    local gL = Instance.new('TextLabel')
    gL.Size = UDim2.new(1, 0, 0.5, 0)
    gL.Position = UDim2.new(0.5, 0, 0.75, 0)
    gL.AnchorPoint = Vector2.new(0.5, 0.5)
    gL.BackgroundTransparency = 1
    gL.Font = Enum.Font.GothamBlack
    gL.TextSize = 32
    gL.Text = '$' .. formatNumber(g) .. '/s'
    gL.TextXAlignment = Enum.TextXAlignment.Center
    gL.Parent = gui
    startRainbow(gL, "TextColor3")
end


local function runPetScanLoop()
    if isPetScanRunning then return end
    isPetScanRunning = true

    while espEnabled do
        local highest, bestGen = nil, -1
        for _, m in ipairs(workspace:GetChildren()) do
            if isBasePet(m) and isInEnemyPlot(m) then
                local g = getFinalGeneration(m)
                if g > bestGen then
                    bestGen = g
                    highest = m
                end
            end
        end

        highestGenAnimal = highest
        clearPetESP()
        if highest then
            attachPetESP(highest, bestGen)
        end

        task.wait(INTERVAL)
    end

    -- Cleanup on stop
    clearPetESP()
    highestGenAnimal = nil
    isPetScanRunning = false
end


function enableHighestGenESP()
    espEnabled = true
    task.spawn(runPetScanLoop)
end

function disableHighestGenESP()
    espEnabled = false
end


enableHighestGenESP()



esp.create_toggle({
	name = 'Esp best brainrot',
	flag = 'espbestbrainrot',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			enableHighestGenESP()
		else
			disableHighestGenESP()
		end
	end
})


-- === UTILITY TAB ===

-- === Utility ===

local player = game:GetService("Players").LocalPlayer
local donetools = {}
local active = false

local function spamTool(tool)
    if tool:IsA("Tool") and not donetools[tool] then
        donetools[tool] = true
        coroutine.wrap(function()
            while active do
                task.wait()
                pcall(function()
                    if tool.Parent == player.Character or tool.Parent == player.Backpack then
                        tool.Parent = player.Character
                        tool:Activate()
                    end
                end)
            end
        end)()
    end
end

local function setupChar(character)
    donetools = {} 
    for _, v in pairs(character:GetChildren()) do
        spamTool(v)
    end
    character.ChildAdded:Connect(spamTool)
end


utility.create_toggle({
	name = 'Auto Hit',
	flag = 'autohit',
	section = 'left',
	enabled = false,
	callback = function(state)
		active = state
		if active and player.Character then
			setupChar(player.Character)
		end
	end
})


player.CharacterAdded:Connect(function(char)
    if active then
        setupChar(char)
    end
end)


utility.create_toggle({
	name = 'Auto Hit Nearby',
	flag = 'autohitnearby',
	section = 'left',
	enabled = false,
	callback = function(s)
		local a = s
		task.spawn(function()
			while a do
				pcall(function()
					local c = game:GetService("Players").LocalPlayer.Character
					local h = c and c:FindFirstChild("HumanoidRootPart")
					local t = game:GetService("Players").LocalPlayer.Backpack:FindFirstChildOfClass("Tool") or c:FindFirstChildOfClass("Tool")
					if not (h and t) then return end
					local l = {}
					for _,p in pairs(game:GetService("Players"):GetPlayers()) do
						local v = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
						if p ~= game:GetService("Players").LocalPlayer and v and (v.Position - h.Position).Magnitude < 20 then
							table.insert(l,{p=p,d=(v.Position - h.Position).Magnitude})
						end
					end
					table.sort(l,function(a,b)return a.d<b.d end)
					for i=1,math.min(#l,3) do
						if not a then return end
						local v = l[i].p.Character and l[i].p.Character:FindFirstChild("HumanoidRootPart")
						if v then
							walkto(v.CFrame)
							t:Activate()
							task.wait(0.05)
						end
					end
				end)
				task.wait()
			end
		end)
	end
})



utility.create_toggle({
	name = 'Anti Teleport',
	flag = 'antiteleport',
	section = 'left',
	enabled = false,
	callback = function(state)
		antiteleport = state
	end
})

local player = game:GetService("Players").LocalPlayer
local tableofconnections = {}
local antiragdoll = false

local function protectTool(tool)
    if tool:IsA("BasePart") then
        -- Prevent anchoring
        table.insert(tableofconnections, tool:GetPropertyChangedSignal("Anchored"):Connect(function()
            if tool.Anchored and antiragdoll then
                tool.Anchored = false
            end
        end))
        -- Remove ragdoll constraints
        table.insert(tableofconnections, tool.ChildAdded:Connect(function(c)
            if c and (c:IsA("BallSocketConstraint") or c:IsA("HingeConstraint") or c.Name == "Attachment") then
                c:Destroy()
                local char = player.Character
                if char and char:FindFirstChildOfClass("Humanoid") then
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    hum:ChangeState(Enum.HumanoidStateType.GettingUp)
                    hum.PlatformStand = false
                    workspace.CurrentCamera.CameraSubject = hum
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then hrp.CanCollide = true end
                end
            end
        end))
    elseif tool:IsA("Humanoid") then
        table.insert(tableofconnections, tool.StateChanged:Connect(function(_, newState)
            if antiragdoll and (newState == Enum.HumanoidStateType.Physics or newState == Enum.HumanoidStateType.Ragdoll) then
                tool:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        end))
    end
end

local function setupChar(character)
    for _, v in pairs(character:GetChildren()) do
        protectTool(v)
    end
    character.ChildAdded:Connect(protectTool)
end

-- Toggle in Utility tab
utility.create_toggle({
	name = 'Anti Ragdoll',
	flag = 'antiragdoll',
	section = 'left',
	enabled = false,
	callback = function(state)
		antiragdoll = state
		for _, conn in pairs(tableofconnections) do
			pcall(function() conn:Disconnect() end)
		end
		table.clear(tableofconnections)
		if state and player.Character then
			setupChar(player.Character)
		end
	end
})

player.CharacterAdded:Connect(function(char)
    if antiragdoll then
        setupChar(char)
    end
end)


local aimcon
local origincamp

utility.create_toggle({
	name = 'Aimbot',
	flag = 'aimbot',
	section = 'left',
	enabled = false,
	callback = function(stat)
		if stat then
			local cam = workspace.CurrentCamera
			origincamp = cam.CameraType
			
			aimcon = game:GetService("RunService").Heartbeat:Connect(function()
				local rootp = player.Character and player.Character.HumanoidRootPart
				local camobj = workspace.CurrentCamera
				
				if rootp and camobj then
					local closestp, mindist = nil, 100
					
					for _, tarp in ipairs(game.Players:GetPlayers()) do
						if tarp ~= player and tarp.Character and tarp.Character.HumanoidRootPart and tarp.Character.Humanoid and tarp.Character.Humanoid.Health > 0 then
							local dist = (rootp.Position - tarp.Character.HumanoidRootPart.Position).Magnitude
							
							if dist < mindist then
								closestp, mindist = tarp, dist
							end
						end
					end
					
					if closestp then
						local tarpos = closestp.Character.HumanoidRootPart.Position
						local campos = (rootp.CFrame + rootp.CFrame.LookVector * -5 + Vector3.new(0, 2, 0)).Position
						camobj.CFrame = CFrame.lookAt(campos, tarpos)
					end
				end
			end)
		else
			if aimcon then
				aimcon:Disconnect()
				aimcon = nil
			end
			
			if origincamp then
				workspace.CurrentCamera.CameraType = origincamp
			end
		end
	end
})


utility.create_toggle({
	name = 'Anti Sentry',
	flag = 'antisentry',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			if AntiSentryConnection then AntiSentryConnection:Disconnect() end

			local Players = game:GetService("Players")
			local RunService = game:GetService("RunService")
			local LocalPlayer = Players.LocalPlayer

			local function getCharacter()
				return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
			end

			local function getHumanoidRootPart()
				return getCharacter():WaitForChild("HumanoidRootPart", 3)
			end

			AntiSentryConnection = RunService.Heartbeat:Connect(function()
				local hrp = getHumanoidRootPart()
				if not hrp then return end

				for _, obj in pairs(workspace:GetChildren()) do
					if obj:IsA("Model") and obj.Name:lower():find("sentry") and obj:FindFirstChild("HumanoidRootPart") then
						local sentryHRP = obj.HumanoidRootPart
						local distance = (sentryHRP.Position - hrp.Position).Magnitude

						if distance <= 70 then
							pcall(function()
								sentryHRP.Anchored = false
								sentryHRP.CanCollide = false
								sentryHRP.Massless = true
								sentryHRP.CFrame = hrp.CFrame + Vector3.new(0, 0, -3)
							end)
						end
					end
				end
			end)
		else
			if AntiSentryConnection then
				AntiSentryConnection:Disconnect()
				AntiSentryConnection = nil
			end
		end
	end
})



local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- 🧠 Runtime flags and memory
local antiTrapEnabled = false
local processedTraps = {}

-- 🚫 Anti Trap logic loop
RunService.Heartbeat:Connect(function()
    if not antiTrapEnabled then return end

    for _, v in ipairs(Workspace:GetDescendants()) do
        if processedTraps[v] then continue end

        if v:IsA("BasePart") and v.Name:lower():find("trap") then
            pcall(function()
                local safe = Instance.new("Part")
                safe.Size = v.Size
                safe.CFrame = v.CFrame
                safe.Anchored = true
                safe.CanCollide = true
                safe.Color = Color3.fromRGB(60, 255, 60)
                safe.Name = "FakeTrap"
                safe.Transparency = 0.3
                safe.Material = Enum.Material.Neon
                safe.Parent = Workspace

                processedTraps[safe] = true
                processedTraps[v] = true
                v:Destroy()
            end)
        elseif v:IsA("Model") and v.Name:lower():find("trap") then
            pcall(function()
                processedTraps[v] = true
                v:Destroy()
            end)
        end
    end
end)

-- 🧩 Fluent UI Toggle Button under Utility tab
utility.create_toggle({
	name = 'Anti Trap',
	flag = 'antitrap',
	section = 'left',
	enabled = false,
	callback = function(state)
		antiTrapEnabled = state
	end
})


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Flag for enabling
local antiInvisEnabled = false

-- Loop to reveal invisible players
RunService.Heartbeat:Connect(function()
    if not antiInvisEnabled then return end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= Players.LocalPlayer and plr.Character then
            for _, part in ipairs(plr.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    pcall(function()
                        part.Transparency = 0
                        part.Color = Color3.fromRGB(255, 60, 60)
                    end)
                end
            end
        end
    end
end)

-- Fluent UI Toggle under Utility tab
utility.create_toggle({
	name = 'Anti Invisibility',
	flag = 'antiinvis',
	section = 'left',
	enabled = false,
	callback = function(state)
		antiInvisEnabled = state
	end
})


utility.create_dropdown({
    name = 'Teleport',
    flag = 'teleporttype',
    section = 'left',
    options = {'Sky','Ground'},
    callback = function(s)
        local c = player.Character
        if c then
            local r = c:FindFirstChild('HumanoidRootPart')
            if r then
                if s == 'Sky' then
                    r.CFrame = r.CFrame + Vector3.new(0,150,0)
                elseif s == 'Ground' then
                    r.CFrame = r.CFrame - Vector3.new(0,189,0)
                end
            end
        end
    end
})



local player = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

getgenv().posgoto = getgenv().posgoto or nil
getgenv().clickToSet = false
getgenv().loopGoto = false

-- Create red marker
local marker = Instance.new("Part")
marker.Anchored = true
marker.CanCollide = false
marker.Size = Vector3.new(4, 0.2, 4)
marker.Material = Enum.Material.Neon
marker.Color = Color3.fromRGB(255, 0, 0)
marker.Transparency = 1
marker.Name = "GotoMarker"
marker.Parent = workspace

-- Set position logic
local function setTargetPosition(worldPos)
    local finalPos = worldPos + Vector3.new(0, 1.5, 0)
    marker.CFrame = CFrame.new(finalPos)
    marker.Transparency = 0
    getgenv().posgoto = CFrame.new(finalPos)
end

-- Raycast from screen
local function castRay(screenPosition)
    local unitRay = Camera:ViewportPointToRay(screenPosition.X, screenPosition.Y)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {player.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = workspace:Raycast(unitRay.Origin, unitRay.Direction * 500, rayParams)
    if result then
        setTargetPosition(result.Position)
    end
end

-- Desktop click
if UserInputService.MouseEnabled then
    local mouse = player:GetMouse()
    mouse.Button1Down:Connect(function()
        if getgenv().clickToSet then
            local mousePos = UserInputService:GetMouseLocation()
            castRay(Vector2.new(mousePos.X, mousePos.Y - 36)) -- Adjust for top bar
        end
    end)
end

-- Mobile tap
UserInputService.TouchTap:Connect(function(tapPositions)
    if getgenv().clickToSet and #tapPositions > 0 then
        castRay(tapPositions[1])
    end
end)

-- Select Position Toggle
utility.create_toggle({
	name = 'Select Position',
	flag = 'selectposition',
	section = 'left',
	enabled = false,
	callback = function(state)
		getgenv().clickToSet = state
		if not state and getgenv().posgoto then
			print("Saved")
		end
	end
})


utility.create_button({
	name = 'Goto Position',
	flag = 'gotopos',
	section = 'left',
	enabled = false,
	callback = function()
      local pos = getgenv().posgoto
      local root = (game:GetService("Players").LocalPlayer.Character or game:GetService("Players").LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart")

      if pos and root then
        bodytp(pos)
      end
	end
})




local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

-- Toggle flag
local bringShopEnabled = false

-- Helper to get local player's HRP
local function getHRP()
    return lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
end

-- Shop bring loop
RunService.Heartbeat:Connect(function()
    if not bringShopEnabled then return end

    local hrp = getHRP()
    if not hrp then return end

    local shop = workspace:FindFirstChild("ShopNPCCash")
    if shop and shop:IsA("Model") and shop:FindFirstChildWhichIsA("BasePart") then
        local root = shop.PrimaryPart or shop:FindFirstChild("HumanoidRootPart") or shop:FindFirstChildWhichIsA("BasePart")
        if root then
            pcall(function()
                root.Anchored = false
                root.CanCollide = false
                root.CFrame = hrp.CFrame + Vector3.new(0, 0, 4)
            end)
        end
    end
end)



-- shop TAB


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local buyRemote = ReplicatedStorage.Packages.Net["RF/CoinsShopService/RequestBuy"]

-- Custom UI Toggle
shop.create_toggle({
	name = 'Bring Shop NPC',
	flag = 'bringshop',
	section = 'left',
	enabled = false,
	callback = function(state)
		bringShopEnabled = state
	end
})


-- List of available tools
local shopItems = {
    "Invisibility Cloak", "Quantum Cloner", "Medusa's Head", "All Seeing Sentry", "Bee Launcher",
    "Boogie Bomb", "Body Swap Potion", "Coil Combo", "Dark Matter Slap", "Diamond Slap",
    "Emerald Slap", "Flame Slap", "Galaxy Slap", "Glitched Slap", "Gold Slap",
    "Grapple Hook", "Gravity Coil", "Iron Slap", "Laser Cape", "Nuclear Slap",
    "Paintball Gun", "Rage Table", "Rainbowrath Sword", "Ruby Slap", "Slap",
    "Speed Coil", "Splatter Slap", "Taser Gun", "Trap", "Web Slinger"
}

-- Buy handler
local function buyItem(itemName)
    local success, result = pcall(function()
        return buyRemote:InvokeServer(itemName)
    end)
    if success then
        print("✅ Bought:", itemName)
    else
        warn("❌ Failed to buy:", itemName)
    end
end

-- Dropdown to select item
local selectedShopItem = shopItems[1]

shop.create_dropdown({
	name = 'Select Tool to Buy',
	flag = 'selectedshopitem',
	section = 'left',
	option = selectedShopItem,
	options = shopItems,
	callback = function(value)
		selectedShopItem = value
	end
})

shop.create_toggle({
	name = 'Buy Selected Tool',
	flag = 'buyselectedtool',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state and selectedShopItem then
			buyItem(selectedShopItem)
		end
	end
})

shop.create_toggle({
	name = 'Buy All Tools',
	flag = 'buyalltools',
	section = 'left',
	enabled = false,
	callback = function(state)
		if state then
			for _, item in ipairs(shopItems) do
				buyItem(item)
				task.wait(0.5)
			end
		end
	end
})


-- webhotsb-Ab

-- 🛠 Lazy-load Roblox services
local svc = setmetatable({}, {
    __index = function(t, k)
        local s = game:GetService(k)
        t[k] = s
        return s
    end
})

-- 🧠 Configuration table (must come first)
local cfg = {
    enabled = true,
    mutenabled = true,
    baseenabled = true,
    webhook = "",
    hoptime = 300,
    brainrots = {},
    mutations = {"Gold", "Diamond", "Rainbow", "Candy"},
    selected = {
        brainrots = {"1", "2"},
        mutations = {"Gold", "Diamond"}
    },
    found = {},
    cons = {}
}


webhook.create_title({
	name = 'Tutorial: Join our Discord to learn how to set up webhooks on mobile or PC.',
	section = 'left'
})

webhook.create_title({
	name = 'What does it do?: Automatically sends mutation types to your Discord!',
	section = 'left'
})


webhook.create_textbox({
    name = 'Webhook URL',
    flag = 'webhook',
    section = 'left',
    value = cfg.webhook,
    callback = function(v)
        cfg.webhook = v
    end
})


-- 🔍 Populate brainrot list
local function getbrainrots()
    cfg.brainrots = {}
    local path = svc.ReplicatedStorage:FindFirstChild("Models")
    if path and path:FindFirstChild("Animals") then
        for _, v in pairs(path.Animals:GetChildren()) do
            if v:IsA("Model") then
                cfg.brainrots[#cfg.brainrots + 1] = v.Name
            end
        end
    end
end

-- 🌐 Send webhook embed
local function sendhook(title, desc)
    if cfg.webhook == "" then return end
    spawn(function()
        pcall(function()
            local serverId = game.JobId
            desc = desc .. "\n\nServer ID: " .. serverId .. "\nJoin Script:\nlua\ngame:GetService('TeleportService'):TeleportToPlaceInstance(" .. game.PlaceId .. ", '" .. serverId .. "')\n"
            request({
                Url = cfg.webhook,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = svc.HttpService:JSONEncode({
                    embeds = {{
                        title = title,
                        description = desc,
                        color = 0x00ff00
                    }}
                })
            })
        end)
    end)
end

-- 🔁 Server hop
local function hop()
    local servers = {}
    local ok, data = pcall(function()
        return request({
            Url = "https://games.roblox.com/v1/games/ " .. game.PlaceId .. "/servers/Public?sortOrder=Desc&limit=100",
            Method = "GET"
        }).Body
    end)

    if ok then
        local success, body = pcall(svc.HttpService.JSONDecode, svc.HttpService, data)
        if success and body.data then
            for _, server in pairs(body.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    servers[#servers + 1] = server.id
                end
            end
        end
    end

    if #servers > 0 then
        local targetServer = servers[math.random(#servers)]
        svc.TeleportService:TeleportToPlaceInstance(game.PlaceId, targetServer, svc.Players.LocalPlayer)
    else
        warn("No available servers to hop to.")
    end
end

-- 🧠 World scanner
local function scan()
    local moving = svc.Workspace:FindFirstChild("MovingAnimals")
    if not moving then return end

    for _, model in pairs(moving:GetChildren()) do
        if model:IsA("Model") then
            local idx, mut = model:GetAttribute("Index"), model:GetAttribute("Mutation")
            if idx then
                local key = tostring(model:GetDebugId())
                if not cfg.found[key] then
                    local notify, info = false, { title = "", desc = "" }

                    for _, brainrot in pairs(cfg.selected.brainrots) do
                        if idx == brainrot then
                            notify = true
                            info.title = "Brainrot Found"
                            info.desc = "Name: " .. brainrot .. (mut and "\nMutation: " .. mut or "")
                            break
                        end
                    end

                    if not notify and cfg.mutenabled and mut then
                        for _, mutation in pairs(cfg.selected.mutations) do
                            if mut == mutation then
                                notify = true
                                info.title = "Mutation Found"
                                info.desc = "Brainrot: " .. idx .. "\nMutation: " .. mut
                                break
                            end
                        end
                    end

                    if notify then
                        cfg.found[key] = true
                        sendhook(info.title, info.desc)
                        print(info.title .. ": " .. info.desc)
                    end
                end
            end
        end
    end
end

-- 🏠 Base scanner
local function scanbase()
    local plots = svc.Workspace:FindFirstChild("Plots")
    if not plots then return end

    for _, plot in pairs(plots:GetChildren()) do
        if plot:IsA("Model") then
            local owner = ""
            local sign = plot:FindFirstChild("PlotSign")
            if sign and sign:FindFirstChild("SurfaceGui") then
                local frame = sign.SurfaceGui:FindFirstChild("Frame")
                if frame and frame:FindFirstChild("TextLabel") then
                    owner = frame.TextLabel.Text
                end
            end

            if owner ~= svc.Players.LocalPlayer.Name then
                local podiums = plot:FindFirstChild("AnimalPodiums")
                if podiums then
                    for _, podium in pairs(podiums:GetChildren()) do
                        if podium:IsA("Model") then
                            local base = podium:FindFirstChild("Base")
                            if base then
                                local spawn = base:FindFirstChild("Spawn")
                                if spawn and spawn:FindFirstChild("Attachment") then
                                    local overhead = spawn.Attachment:FindFirstChild("AnimalOverhead")
                                    if overhead then
                                        local name = overhead:FindFirstChild("DisplayName")
                                        local mut = overhead:FindFirstChild("Mutation")

                                        if name and name.Text ~= "" then
                                            local key = plot.Name .. "_" .. podium.Name
                                            if not cfg.found[key] then
                                                local notify, info = false, { title = "", desc = "" }
                                                local brainrotname = name.Text
                                                local muttext = mut and mut.Text or ""

                                                for _, brainrot in pairs(cfg.selected.brainrots) do
                                                    if brainrotname == brainrot then
                                                        notify = true
                                                        info.title = "Base Brainrot Found"
                                                        info.desc = "Owner: " .. owner .. "\nName: " .. brainrot
                                                        if muttext ~= "" then
                                                            info.desc = info.desc .. "\nMutation: " .. muttext
                                                        end
                                                        break
                                                    end
                                                end

                                                if not notify and cfg.mutenabled and muttext ~= "" then
                                                    for _, mutation in pairs(cfg.selected.mutations) do
                                                        if muttext == mutation then
                                                            notify = true
                                                            info.title = "Base Mutation Found"
                                                            info.desc = "Owner: " .. owner .. "\nBrainrot: " .. brainrotname .. "\nMutation: " .. mutation
                                                            break
                                                        end
                                                    end
                                                end

                                                if notify then
                                                    cfg.found[key] = true
                                                    sendhook(info.title, info.desc)
                                                    print(info.title .. ": " .. info.desc)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

-- 🚀 Start scanning
getbrainrots()

cfg.cons.scan = task.spawn(function()
    while cfg.enabled do
        scan()
        task.wait(1) -- Scan once per second
    end
end)

cfg.cons.basescan = task.spawn(function()
    while cfg.enabled do
        scanbase()
        task.wait(5) -- Scan bases every 5 seconds
    end
end)

cfg.cons.hop = task.spawn(function()
    while cfg.enabled do
        task.wait(cfg.hoptime)
        if cfg.enabled then hop() end
    end
end)



-- === Auto Tab ===

local function conversor(x)
    x = tostring(x):gsub(",", ""):lower()
    local n, s = x:match("([%d%.]+)([kmb]?)")
    n = tonumber(n)
    if not n then return nil end
    if s == "k" then n = n * 1e3 end
    if s == "m" then n = n * 1e6 end
    if s == "b" then n = n * 1e9 end
    return n
end

auto.create_textbox({
    name = "Minimum BrainRot Price",
    flag = "min_brainrot_price",
    section = "left",
    value = tostring(_G.MinPrice or 0),
    callback = function(v)
        _G.MinPrice = tonumber(v) or 0
    end
})

auto.create_textbox({
    name = "Maximum BrainRot Price",
    flag = "max_brainrot_price",
    section = "left",
    value = tostring(_G.MaxPrice or 1500),
    callback = function(v)
        _G.MaxPrice = tonumber(v) or 1500
    end
})

auto.create_multidropdown({
    name = "Select Mutations",
    flag = "mutations",
    section = "left",
    options = {"Gold","Diamond","Bloodrot","Rainbow","Candy","🦀","🌮"},
    callback = function(s)
        _G.Mutations = s
    end
})

auto.create_multidropdown({
    name = "Select Rarity",
    flag = "rarities",
    section = "left",
    options = {"Common","Rare","Epic","Legendary","Mythic","Brainrot God","Secret"},
    callback = function(s)
        _G.Rarities = s
    end
})

function selectedmut(x)
    if not _G.Mutations then return false end
    for _,v in ipairs(_G.Mutations) do
        if v:find(x) then return true end
    end
    return false
end

function selectedrar(x)
    if not _G.Rarities then return false end
    for _,v in ipairs(_G.Rarities) do
        if v:find(x) then return true end
    end
    return false
end

auto.create_toggle({
    name = "Auto Buy BrainRots",
    flag = "autobuy_brainrots",
    section = "left",
    enabled = false,
    callback = function(e)
        _G.AutoBuyBrainrots = e
        if e then
            task.spawn(function()
                while _G.AutoBuyBrainrots do
                    task.spawn(function()
                        bodytp(CFrame.new(-410.522003,-6.50197983,111.718842,0.998981535,0,-0.0451212265,0,1,0,0.0451212265,0,0.998981535))
                    end)
                    pcall(function()
                        local ma = game.Workspace:FindFirstChild("MovingAnimals")
                        for _,a in ipairs((ma or {}):GetDescendants()) do
                            local hrp = a:FindFirstChild("HumanoidRootPart")
                            local inf = hrp and hrp:FindFirstChild("Info")
                            local oh = inf and inf:FindFirstChild("AnimalOverhead")
                            if oh then
                                local pt = oh:FindFirstChild("Price")
                                local prc = pt and pt.Text and conversor(pt.Text)
                                if prc and _G.MinPrice and _G.MaxPrice and prc >= _G.MinPrice and prc <= _G.MaxPrice then
                                    local mut = oh:FindFirstChild("Mutation")
                                    local rar = oh:FindFirstChild("Rarity")
                                    if (mut and mut.Text and selectedmut(mut.Text)) or (rar and rar.Text and selectedrar(rar.Text)) then
                                        local att = hrp:FindFirstChild("PromptAttachment")
                                        local prpt = att and att:FindFirstChild("ProximityPrompt")
                                        if prpt then
                                            pcall(function()
                                                fireproximityprompt(prpt)
                                            end)
                                        end
                                    end
                                end
                            end
                        end
                    end)
                    task.wait(1)
                end
            end)
        end
    end
})


-- === NOTIFICATIONS / STARTUP ===

print("Moondiety Loaded")

local function teleportPlayerTo(cf)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = cf
    end
end

return {
	teleportPlayerTo = teleportPlayerTo
}, library


    